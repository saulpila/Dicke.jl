<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DickeBCE (Quantum Dicke) · Dicke.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/customcss.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Dicke.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">The Dicke.jl package</a></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../ClassicalDicke/">ClassicalDicke</a></li><li><a class="tocitem" href="../DickeBCE/">DickeBCE</a></li><li><a class="tocitem" href="../UPOS/">UPOS</a></li><li><a class="tocitem" href="../TruncatedWignerApproximation/">TruncatedWignerApproximation</a></li><li><a class="tocitem" href="../DickeHusimiProjections/">DickeHusimiProjections</a></li><li><a class="tocitem" href="../ClassicalLMG/">ClassicalLMG</a></li><li><a class="tocitem" href="../ClassicalSystems/">ClassicalSystems</a></li><li><a class="tocitem" href="../PhaseSpaces/">PhaseSpaces</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../ClassicalDickeExamples/">ClassicalDicke</a></li><li class="is-active"><a class="tocitem" href>DickeBCE (Quantum Dicke)</a><ul class="internal"><li><a class="tocitem" href="#Diagonalizing-the-Dicke-Hamiltonian"><span>Diagonalizing the Dicke Hamiltonian</span></a></li><li><a class="tocitem" href="#quantumldoscoherentstateex"><span>Local density of states of a coherent state</span></a></li><li><a class="tocitem" href="#TWAvsQuantum"><span>Evolution of coherent state vs TWA</span></a></li><li><a class="tocitem" href="#exampletolhusimis"><span>Efficient Husimi functions</span></a></li><li><a class="tocitem" href="#wignerfuncexample"><span>Projected Wigner function of a cat state</span></a></li></ul></li><li><a class="tocitem" href="../DickeHusimiProjectionsExamples/">DickeHusimiProjections</a></li><li><a class="tocitem" href="../TruncatedWignerApproximationExamples/">TruncatedWignerApproximation</a></li><li><a class="tocitem" href="../ClassicalLMGExamples/">ClassicalLMG</a></li><li><a class="tocitem" href="../UPOSExamples/">UPOS</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>DickeBCE (Quantum Dicke)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DickeBCE (Quantum Dicke)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/saulpila/Dicke.jl/blob/master/docs/src/DickeBCEExamples.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples-for-DickeBCE"><a class="docs-heading-anchor" href="#Examples-for-DickeBCE">Examples for DickeBCE</a><a id="Examples-for-DickeBCE-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-for-DickeBCE" title="Permalink"></a></h1><p>The module <a href="../DickeBCE/#Dicke.DickeBCE"><code>Dicke.DickeBCE</code></a> works with the quantum Dicke model using a very efficient basis known as the coherent efficient basis (BCE for its acronym in Spanish). See Refs. <a href="../references/#Bastarrachea2014PSa">[4]</a> and <a href="../references/#Bastarrachea2014PSb">[5]</a> for a detailed explanation on how and why it works.  Throughout this examples, we will work with a system size of <code>j = 30</code>, but  using this module you can easily go up to <code>j = 100</code>, as done in Refs. <a href="../references/#Pilatowsky2021">[12]</a>, <a href="../references/#Pilatowsky2021NatCommun">[13]</a>,  <a href="../references/#Villasenor2021">[18]</a>.</p><h2 id="Diagonalizing-the-Dicke-Hamiltonian"><a class="docs-heading-anchor" href="#Diagonalizing-the-Dicke-Hamiltonian">Diagonalizing the Dicke Hamiltonian</a><a id="Diagonalizing-the-Dicke-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonalizing-the-Dicke-Hamiltonian" title="Permalink"></a></h2><p>Let us start by defining our parameters:</p><pre><code class="language-julia">using Dicke.DickeBCE, Dicke.ClassicalDicke
systemQ = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j=30, Nmax=120)</code></pre><p>To load the eigenbasis, simply use <a href="../DickeBCE/#Dicke.DickeBCE.diagonalization"><code>diagonalization</code></a>:</p><pre><code class="language-julia">@time eigenenergies,eigenstates =  diagonalization(systemQ)</code></pre><pre class="documenter-example-output">[ Info: Diagonalizing...
[ Info: 3454 converged states were obtained up to ϵ=1.1807678467701475.
[ Info: Fixing numerical degeneracies (correcting parity).
600.878784 seconds (234.05 M allocations: 7.608 GiB, 0.39% gc time, 0.61% compilation time)</pre><p>This saves the diagonalization to disk, so next time you can do:</p><pre><code class="language-julia">systemQ = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j = 30)
@time eigenenergies,eigenstates =  diagonalization(systemQ)</code></pre><pre class="documenter-example-output">[ Info: Loading diagonalization: Nmax=120
 21.121601 seconds (29.46 M allocations: 2.180 GiB, 1.91% gc time, 2.04% compilation time)</pre><p>(Note that we did not have to pass <code>Nmax</code> this time, it loaded it from disk.)</p><p>The resulting <code>eigenstates</code> form a matrix. To get the <span>$k$</span>th eigenstate, simply do <code>state_k = eigenstates[:,k]</code>.</p><h2 id="quantumldoscoherentstateex"><a class="docs-heading-anchor" href="#quantumldoscoherentstateex">Local density of states of a coherent state</a><a id="quantumldoscoherentstateex-1"></a><a class="docs-heading-anchor-permalink" href="#quantumldoscoherentstateex" title="Permalink"></a></h2><p>In this example, we obtain the eigenenergy components of a coherent state.</p><pre><code class="language-julia">using Plots
using Dicke.DickeBCE, Dicke.ClassicalDicke
j = 30
systemC = ClassicalDickeSystem(ω=1.0, γ=1.0, ω₀=1.0)
systemQ = QuantumDickeSystem(systemC, j = j, Nmax=120)
eigenenergies,eigenstates = diagonalization(systemQ)

ϵₓ = -0.5
x = Point(systemC, Q=-1, P=0, p=0, ϵ=ϵₓ)
coh_state = coherent_state(systemQ, x)
coherent_state_eigenbasis = transpose(eigenstates)*coh_state
abscₖ²=abs2.(coherent_state_eigenbasis)
ϵₖs = eigenenergies/j


plot(histogram(ϵₖs, weights=abscₖ²,
        ylabel=&quot;Probability density&quot;, xticks=:none,normed=true,nbins=50),

    scatter(ϵₖs, abscₖ², ylabel=&quot;|cₖ|²&quot;, xlabel=&quot;ϵ&quot;),

   size=(700,500), key=false, layout=(@layout [°;°]),
   xlim=(ϵₖs[1],ϵₖs[end]))</code></pre><p><img src="../LDoS_quantum.svg" alt/></p><p>See <a href="../TruncatedWignerApproximationExamples/#semiclassicalLDoS">this example</a> for a semiclassical computation of the envelope of this function.</p><h2 id="TWAvsQuantum"><a class="docs-heading-anchor" href="#TWAvsQuantum">Evolution of coherent state vs TWA</a><a id="TWAvsQuantum-1"></a><a class="docs-heading-anchor-permalink" href="#TWAvsQuantum" title="Permalink"></a></h2><p>Let us compare the evolution of a quantum state with that given by truncated Wigner approximation (see Refs. <a href="../references/#Villasenor2020">[17]</a>, <a href="../references/#Pilatowsky2020">[11]</a>).</p><pre><code class="language-julia">using Plots
using Dicke.TruncatedWignerApproximation
using Dicke.DickeBCE, Dicke.ClassicalDicke
using LinearAlgebra
j = 30
systemC = ClassicalDickeSystem(ω=1.0, γ=1.0, ω₀=1.0)
systemQ = QuantumDickeSystem(systemC, j = j, Nmax=120)
eigenenergies,eigenstates =  diagonalization(systemQ)

x = Point(systemC, Q=1.75, P=0, p=0, ϵ=-0.5)
coh_state=coherent_state(systemQ, x)
W = coherent_Wigner_HWxSU2(x,j=j)
nothing #hide</code></pre><p>First, we compare the expectation value of the observable <span>$\hat{J}_z^2$</span>. Note that we use <a href="../TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jz²-Tuple{Real}"><code>Weyl.Jz²</code></a><code>(j)</code>, which is not the same as <a href="../TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jz-Tuple{Real}"><code>Weyl.Jz</code></a><code>(j)^2</code>.</p><pre><code class="language-julia">ts= 0:0.05:40
evolution = evolve(ts, coh_state,
                eigenstates=eigenstates,
                eigenenergies=eigenenergies);
Jz²=DickeBCE.Jz(systemQ)^2
exvals = [real(dot(v,Jz²,v)) for v in eachcol(evolution)]

N=20000
if !on_github N=1000 end
TWA = average(systemC,
         distribution = W,
         observable = Weyl.Jz²(j),
         ts = ts,
         N = N)

plot(ts, [exvals TWA],
    size=(700,350), label=[&quot;Quantum&quot; &quot;TWA&quot;],
    xlabel = &quot;time&quot;, ylabel=&quot;Jz²&quot;)</code></pre><p><img src="../Jz2_QvsTWA.svg" alt/></p><p>Now let us take a look at the survival probability (see Ref. <a href="../references/#Villasenor2020">[17]</a>).</p><pre><code class="language-julia">ts=exp10.(-2:0.01:3)

N=20000
if !on_github N=1000 end
classical_SP = TruncatedWignerApproximation.survival_probability(
    systemC;
    distribution = W,
    N=N, ts=ts
)
quantum_SP = DickeBCE.survival_probability(
    ts,
    state=coh_state,
    eigenstates=eigenstates,
    eigenenergies=eigenenergies
)

plot(ts, [quantum_SP classical_SP],
    yscale=:log10, xscale=:log10,
    ylim=(1e-4,1), label=[&quot;Quantum&quot; &quot;TWA&quot;],
    xlabel=&quot;time&quot;, ylabel=&quot;Survival probability&quot;)</code></pre><p><img src="../SP_QvsTWA.svg" alt/></p><h2 id="exampletolhusimis"><a class="docs-heading-anchor" href="#exampletolhusimis">Efficient Husimi functions</a><a id="exampletolhusimis-1"></a><a class="docs-heading-anchor-permalink" href="#exampletolhusimis" title="Permalink"></a></h2><p>The functions <a href="../DickeBCE/#Dicke.DickeBCE.husimi"><code>DickeBCE.husimi</code></a>,  <a href="../DickeBCE/#Dicke.DickeBCE.coherent_overlap"><code>DickeBCE.coherent_overlap</code></a>, and <a href="../DickeBCE/#Dicke.DickeBCE.coherent_state"><code>DickeBCE.coherent_state</code></a> all accept a <code>tol</code> argument, which allows to significally speed up computation time at the cost of slight numerical precision <a href="../references/#Pilatowsky2020Notes">[10]</a>. In this example we show how significant this speedup can be. Let us construct a big system:</p><pre><code class="language-julia">using Dicke
using Dicke.DickeBCE
using Dicke.ClassicalDicke
using LinearAlgebra

j = 600
Nmax = 1200
system = QuantumDickeSystem(ω₀=1, ω=1, γ=1, j=j, Nmax=Nmax);</code></pre><p><strong>Do not try to diagonalize such a big system! Your computer might explode!</strong></p><p>For the sake of example, let us construct some random states in a simple manner (although if you are interested in building random states in the eigenbasis, check the function <a href="../DickeBCE/#Dicke.DickeBCE.random_state"><code>DickeBCE.random_state</code></a>).</p><pre><code class="language-julia">n = 3 #how many random vectors
D = dimension(system)
random_vectors = rand(ComplexF64,(D,n))
for i in 1:n
    random_vectors[:,i] /= norm(@view random_vectors[:,i]) #normalize each one
end</code></pre><p><code>random_vectors</code> is a matrix with <code>n</code> columns (states). Let us fix a point in the phase space:</p><pre><code class="language-julia">x = Point(Q=0.6, P=-0.1, p=-0.2, q=-0.8)</code></pre><p>We may call <a href="../DickeBCE/#Dicke.DickeBCE.husimi"><code>husimi</code></a><code>(system, x, random_vectors)</code>, which will return an array with <code>n</code> elements. The <code>i</code>th element is the result of evaluating the Husimi function  of the <code>i</code>th state (column) at the point <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; @time husimi(system, x, random_vectors, tol=0)
 14.243865 seconds (34.10 M allocations: 927.095 MiB, 5.10% gc time, 2.55% compilation time)
3-element Vector{Float64}:
 1.2746734986914377e-7
 6.20535210800852e-8
 2.7064608829056714e-7</code></pre><p>By passing <code>tol=0</code> we are allowing for no optimization. The code has to build all the coefficients of the coherent state and then multiply them by each coefficient in <code>random_vectors</code>. However, if we allow <code>tol</code> to be slightly bigger, things will speed up significantly:</p><pre><code class="language-julia-repl">julia&gt; @time husimi(system, x, random_vectors, tol=1e-14)
  0.079492 seconds (456.54 k allocations: 13.270 MiB, 27.99% compilation time)
3-element Vector{Float64}:
 1.274678835723417e-7
 6.205397710320293e-8
 2.70646320639564e-7</code></pre><p>Note that the results barely changed, but this time it used a lot less memory and time. The <code>tol</code> argument tells the code it can <em>chop</em> a portion of size <code>tol</code> off the tails of the distribution of the coherent state (see Ref. <a href="../references/#Pilatowsky2020Notes">[10]</a> for details). You loose almost no information,  and you gain a lot of time. The default is <code>tol = 1e-6</code>, which gives enough precision for most purposes (although you may increase it if you need more precision):</p><pre><code class="language-julia-repl">julia&gt; @time husimi(system, x, random_vectors) #default tol = 1e-6
  0.028671 seconds (194.72 k allocations: 5.249 MiB)
3-element Vector{Float64}:
 1.285460060073177e-7
 6.239461243180415e-8
 2.7032019935286814e-7</code></pre><p>That&#39;s fast!</p><h2 id="wignerfuncexample"><a class="docs-heading-anchor" href="#wignerfuncexample">Projected Wigner function of a cat state</a><a id="wignerfuncexample-1"></a><a class="docs-heading-anchor-permalink" href="#wignerfuncexample" title="Permalink"></a></h2><p>Using <a href="../DickeBCE/#Dicke.DickeBCE.WignerProjqp"><code>DickeBCE.WignerProjqp</code></a>, we may compute the Wigner function of a state, projected onto the atomic plane. Note: the functions for computing Wigner functions are not thoroughly tested. They are based on these notes <a href="../references/#Pilatowsky2019Notes">[9]</a></p><pre><code class="language-julia">using Dicke.ClassicalDicke, Dicke.DickeBCE
systemC = ClassicalDickeSystem(ω=1.0, γ=1.0, ω₀=1.0)
systemQ = QuantumDickeSystem(systemC, j=10, Nmax=50)
res=0.05
if !on_github res=0.2 end #end
Qs=Ps=-2:res:2
pts=[[Q,P] for Q in Qs, P in Ps if Q^2+P^2 &lt;= 4]

x = Point(Q=-1.0, P=0, p=0, q=0)
y = Point(Q= 1.0, P=0, p=0, q=0)
🐱 = 1/sqrt(2) * (coherent_state(systemQ, x) + coherent_state(systemQ, y))

W=DickeBCE.WignerProjqp(systemQ,
                    [🐱],
                    pts
                    )[1]
d=Dict(zip(pts,W))
function mW(Q,P)
    if [Q,P] in pts
        return d[[Q,P]]
    else
        return NaN
    end
end
heatmap(Qs, Ps, mW, size=(600,600),
    xlabel = &quot;Q&quot;, ylabel = &quot;P&quot;,
    c=cgrad(:bwr, rev = true), clim=(-2.5,2.5))</code></pre><p><img src="../catWigner.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ClassicalDickeExamples/">« ClassicalDicke</a><a class="docs-footer-nextpage" href="../DickeHusimiProjectionsExamples/">DickeHusimiProjections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Friday 16 July 2021 01:53">Friday 16 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
