var documenterSearchIndex = {"docs":
[{"location":"TruncatedWignerApproximationExamples/#Examples-for-TrucatedWingerApproximation","page":"Truncated Wigner Approximation","title":"Examples for TrucatedWingerApproximation","text":"","category":"section"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\nusing Dicke","category":"page"},{"location":"TruncatedWignerApproximationExamples/#Classical-evolution-of-coherent-states","page":"Truncated Wigner Approximation","title":"Classical evolution of coherent states","text":"","category":"section"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"The module Dicke.TruncatedWignerApproximation is a very powerful tool to study the classical evolution of distributions in the phase space.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"Let us load the module Dicke.TruncatedWignerApproximation, together with Distributed which allows paralelization.  ","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"using Distributed\nusing Plots,Plots.PlotMeasures\nusing Dicke,Dicke.TruncatedWignerApproximation, Dicke.ClassicalDicke\nif false #hide\naddprocs(2) #we add 2 workers. Add as many as there are cores in your computer.\n@everywhere using Dicke,Dicke.TruncatedWignerApproximation\nend #hide","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"The functions from Dicke.TruncatedWignerApproximation will make use of all the available workers.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"For our first example, let us consider the Wigner function of a coherent state, evolve it classically using the truncated Wigner approximation, and then look at  the expected value of the Weyl symbol of the observable hatj_z=hatJ_zj in time with  TruncatedWignerApproximation.average. Note the usage of Weyl.Jz.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"system = ClassicalDickeSystem(ω=1.0, γ=1.0, ω₀=1.0)\nx = Point(system, Q=1, P=1, p=0, ϵ=0.5)\nj = 300\nW = coherent_Wigner_HWxSU2(x,j=j)\njz = Weyl.Jz(j)/j \ntimes = 0:0.05:40\nif !on_github  times=0:1:4 end #hide\n\nN = 20000\nif !on_github N=200 end #hide\njz_average=average(system;observable=jz, distribution=W, N = N, ts=times)\nplot(times,jz_average, xlabel=\"time\", \n    ylabel=\"jz\",key=false,ylim=(-1,1), size=(700,350))\nsavefig(\"average_jz_TWA.svg\");nothing #hide","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"Okay, but we can do more. Let's see how the whole distribution of j_z evolves classically using TruncatedWignerApproximation.calculate_distribution.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"y_axis_values = -1.1:0.01:1.1\nmatrix = calculate_distribution(system; distribution=W, N = N,\n    x=:t,  ts=times,\n    y=jz, ys=y_axis_values)\nheatmap(times, y_axis_values, matrix,\n    size=(700,350), color=cgrad(:gist_heat, rev=true),\n    xlabel=\"time\", ylabel=\"jz\")\nsavefig(\"distribution_jz_TWA.svg\");nothing #hide","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"We can chain several computations using TruncatedWignerApproximation.mcs_chain.  For example, let's see the evolution of q and p for the same coherent state evolving in time, along with the time-averaged distribution in the plane qp.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"qs=-4.2:0.05:4.2\nps=-2.4:0.05:2.4\nif !on_github  qs=-4.2:0.5:4.2;ps=-2.4:0.5:2.4 end #hide\nmcs=mcs_chain(\n    mcs_for_distributions(\n        system; N = N, \n        distribution=W,\n        y=:t,  ts=times,\n        x=:q, xs=qs),\n    mcs_for_distributions(\n            system; N = N,\n            distribution=W,\n            y=:p, ys=ps,\n            x=:t,  ts=times),\n    mcs_for_distributions(\n        system; N = N,\n        distribution=W,\n        x=:q,  xs=qs,\n        y=:p, ys=ps,ts=times)\n)\nmatrix_q_vs_t,matrix_t_vs_p,matrix_q_vs_p = monte_carlo_integrate(system,\n    mcs;ts=times,N=N,distribution=W,tolerate_errors=false)\n    \n    \nplot(heatmap(qs,times, matrix_q_vs_t,\n        color=cgrad(:gist_heat, rev=true),\n        ylabel=\"time\", xlabel=\"q\",xmirror =true,ymirror =true, bottom_margin = -15mm),\n    heatmap(times,ps, matrix_t_vs_p,\n        color=cgrad(:gist_heat, rev=true),\n        xlabel=\"time\", ylabel=\"p\", right_margin = -15mm),\n    heatmap(qs,ps, matrix_q_vs_p,\n        color=cgrad(:gist_heat, rev=true),\n        ticks=:none,size=(400,400),margin = -15mm),\n    layout=(@layout [_ °; \n                     ° °]), \n    color=cgrad(:gist_heat, rev=true),\n    size=(800,800),colorbar=:none,link=:both)\nsavefig(\"distribution_qptime_TWA.svg\");nothing #hide.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"The function calculate_distribution can even animate the evolution (with a little help from the wonderful @animate from Plots).","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"N = 1000000\ntimes = 0:0.1:40\nif !on_github N=200 end #hide\nif !on_github times=0:1 end #hide\n\nmatrices = calculate_distribution(system; distribution=W, N = N,\n    x=:q,y=:p,xs=qs, ys=ps,ts=times,animate=true,maxNBatch=200000);\nanimation=@animate for mat in matrices\n    heatmap(qs, ps, mat,\n        color=cgrad(:gist_heat, rev=true),size=(600,600),xlabel=\"q\",ylabel=\"p\",key=false)\nend\nmp4(animation,\n    \"animation_of_evolution.mp4\",\n    show_msg=false, #hide\n    fps=30)\nnothing; #hide","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/#Fidelity-out-of-time-order-correlator-(FOTOC)","page":"Truncated Wigner Approximation","title":"Fidelity out-of-time order correlator (FOTOC)","text":"","category":"section"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"The FOTOC is a quantum-equivalent of the classcal Lyapunov exponent. It is just the variance textvar(Q)+textvar(q)+textvar(P)+textvar(p) as a function of time. It may be calculated using the TWA.  (See Ref. [4] and references therein).","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"using Dicke.ClassicalDicke\nusing Dicke.ClassicalSystems\nusing Dicke.TruncatedWignerApproximation\nusing Plots\nsystem = ClassicalDickeSystem(ω=1.0, γ=1.0, ω₀=1.0)\n\nts = 0:0.1:50\nj = 1000\nx = Point(system, Q=-1, P=0, p=0, ϵ=-0.6)\nW = coherent_Wigner_HWxSU2(x, j=j)\nN = 10000\nif !on_github N=200 end #hide\nif !on_github times=0:1:10 end #hide\n\nFOTOC=sum.(variance(system; observable=[:Q,:p,:P,:p], \n                    distribution=W, N=N, ts=ts, tol=1e-8))\n\nplot(ts, FOTOC, \n     xlabel=\"time\", ylabel=\"FOTOC\",\n     label=\"FOTOC\", yscale=:log10)\nlyapunov = lyapunov_exponent(system, u₀=x)\nplot!(t->exp(2*lyapunov*t)*2/j, 0, 14, \n    label=\"exp(2λt)*2ħ\", key=:bottomright)\nsavefig(\"FOTOC_TWA.svg\");nothing #hide.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/#Energy-profiles-of-coherent-states","page":"Truncated Wigner Approximation","title":"Energy profiles of coherent states","text":"","category":"section"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"We have a semiclassical formula for the energy width of a coherent state, given in App. A of Ref. [3], and implemented in ClassicalDicke.energy_width_of_coherent_state. Let's check this formula against the semiclassical local density of states given by Eq. (E.3) of Ref. [9].","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"using Dicke.ClassicalDicke\nusing Dicke.ClassicalSystems\nusing Dicke.TruncatedWignerApproximation\nusing Distributions\nusing Plots\nsystem = ClassicalDickeSystem(ω=1.0, γ=1.0, ω₀=1.0)\n\nts = 0:0.1:50\nj = 1000\nϵₓ = -0.5\nx = Point(system, Q=-1, P=0, p=0, ϵ=ϵₓ)\nW = coherent_Wigner_HWxSU2(x, j=j)\nN = 1000000\n\nhamiltonian = ClassicalDicke.hamiltonian(system)\nϵ_binsize = 0.01\nif !on_github N=1000 end #hide\nif !on_github ϵ_binsize=0.1 end #hide\n\nϵs = -0.8:ϵ_binsize:0\nρ = calculate_distribution(system, distribution=W, \n    N=N,x=hamiltonian,xs=ϵs)'\nρ /= sum(ρ)*ϵ_binsize #normalization\nσₓ = energy_width_of_coherent_state(system, x, j)\ngaussian=Distributions.Normal(ϵₓ, σₓ)\n\nplot(ϵs,ρ, label=\"∫ w(x) δ(ϵ - h(x)) dx\")\nplot!(ϵ->pdf(gaussian,ϵ), ϵs, \n    label=\"normal(σ)\", linestyle=:dash,\n    xlabel=\"ϵ\", ylabel=\"Probability density\")\nsavefig(\"LDoS_classical.svg\");nothing #hide.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"DickeHusimiProjections/#Dicke.DickeHusimiProjections","page":"DickeHusimiProjections","title":"Dicke.DickeHusimiProjections","text":"","category":"section"},{"location":"DickeHusimiProjections/","page":"DickeHusimiProjections","title":"DickeHusimiProjections","text":"Modules = [Dicke.DickeHusimiProjections]\nOrder   = [:function, :type]","category":"page"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation","text":"","category":"section"},{"location":"TruncatedWignerApproximation/","page":"TruncatedWignerApproximation","title":"TruncatedWignerApproximation","text":"Modules = [Dicke.TruncatedWignerApproximation]\nOrder   = [:type,:function]","category":"page"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.MonteCarloSystem","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.MonteCarloSystem","text":"struct MonteCarloSystem\n\nThis object may be passed to monte_carlo_integrate. Use mcs_for_averaging,  mcs_for_variance, and mcs_for_survival_probability to generate them,  and mcs_chain to join them together.\n\n\n\n\n\n","category":"type"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.PhaseSpaceDistribution","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.PhaseSpaceDistribution","text":"struct PhaseSpaceDistribution\n\nThis object represents a probability distribution in the phase space. Currently, the only  implementation is through coherent_Wigner_HWxSU2.\n\n\n\n\n\n","category":"type"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.average-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.average","text":"function average(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_averaging]]],\n    kargs...)\n\nCalls mcs_for_averaging and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.calculate_distribution-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.calculate_distribution","text":"function calculate_distribution(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_distributions]]],\n    kargs...)\n\nCalls mcs_for_distributions and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_HW-Tuple{Any}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_HW","text":"function  coherent_Wigner_HW(u₀::AbstractVector{<:Real},j::Real=1,ħ::Real=1/j)\n\nSame as coherent_Wigner_HW, taking u₀ = [q₀, p₀].\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_HW-Tuple{}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_HW","text":"function coherent_Wigner_HW(;q₀::Real,p₀::Real,j::Real=1,ħ::Real=1/j)\n\nReturns a PhaseSpaceDistribution corresponding to the two-dimensional Wigner function of a coherent state of the Heisenberg-Weyl algebra (i.e. a standard coherent state)  centered at q₀,p₀. A value of ħ may be passed, or pass j to set ħ = 1/j. (See Eq. (B.1) of Ref. [9])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_HWxSU2-Tuple{AbstractVector{var\"#s142\"} where var\"#s142\"<:Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_HWxSU2","text":"function  coherent_Wigner_HWxSU2(u₀::AbstractVector{<:Real},j::Real=1,ħ::Real=1/j)\n\nSame as coherent_Wigner_HWxSU2, taking u₀ = [Q₀, q₀, P₀, p₀].\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_HWxSU2-Tuple{}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_HWxSU2","text":"function coherent_Wigner_HWxSU2(;Q₀::Real,q₀::Real,P₀::Real,p₀::Real,j::Real=1,ħ::Real=1/j)\n\nProduces the Wigner function corresponding to the tensor product of coherent_Wigner_HW and coherent_Wigner_SU2.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_SU2-Tuple{Any}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_SU2","text":"function  coherent_Wigner_SU2(u₀::AbstractVector{<:Real},j::Real=1,ħ::Real=1/j)\n\nSame as coherent_Wigner_SU2, taking u₀ = [Q₀, P₀].\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_SU2-Tuple{}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_SU2","text":"function coherent_Wigner_HW(;Q₀::Real,P₀::Real,j::Real=1,ħ::Real=1/j)\n\nSame as coherent_Wigner_HW, but for a coherent state for the SU(2)  algebra (a Bloch coherent state).  The approximation given by Eq. (B.4) of Ref. [9] is used.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_chain-Tuple{AbstractVector{Dicke.TruncatedWignerApproximation.MonteCarloSystem}}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_chain","text":"function mcs_chain(Fs::AbstractArray{MonteCarloSystem,1})\n\nGenerates a MonteCarloSystem by chaining together those in the array Fs = [monteCarloSystem1, monteCarloSystem2, ...]. The output of the system generated is an array that has the outputs of each system, in the same order as Fs.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_chain-Union{Tuple{Vararg{Dicke.TruncatedWignerApproximation.MonteCarloSystem, N}}, Tuple{N}} where N","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_chain","text":"function mcs_chain(mcs1::MonteCarloSystem, mcs2::MonteCarloSystem, ...)\n\nFunctionally equivalent to mcs_chain([mcs1, mcs2, ...]).\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_for_averaging-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_for_averaging","text":"function mcs_for_averaging(\n    system::ClassicalSystems.ClassicalSystem;\n    observable,\n    ts::AbstractVector{<:Real}=[0.0],\n    N::Integer,\n    distribution::PhaseSpaceDistribution)\n\nGenerates a MonteCarloSystem that computes\n\n    frac1N sum_i=1^N textobservable(mathbfx_i(t))\n\nfor each t in ts, where mathbfx_i will be sampled from distribution. The system produces an array the same size as ts, containing the result for each time.\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem,\nobservable can a function in the form f(x::Vector) or f(x1,x2 ,..., x_n) with  n the dimension of the phase space determined by system. observable can also be an expression determining the operations between the varnames determined by system. For example, if system were a instance of ClassicalDicke.ClassicalDickeSystem, then observable could be :(q+p^2 +Q), f(Q, q, P, p) = q + p^2 - Q or f(x) = x[2] + x[4]^2 - x[1], which are all equivalent. See also the submodule Weyl, which produces expressions corresponding to  the Weyl symbols of quantum observables.   Note: observable can also be an array of observables, in which case an array is returned for each time.\nts should be a sorted array of times.\nN is the number of points to sample. The bigger the more accurate.\ndistribution should be an instance of PhaseSpaceDistribution\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_for_distributions-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_for_distributions","text":"function mcs_for_distributions(system::ClassicalSystems.ClassicalSystem;\n    x,\n    xs::Union{AbstractRange{<:Real},Nothing}=nothing,\n    y=nothing,\n    ts::Union{AbstractRange{<:Real},Nothing}=nothing,\n    animate::Bool=false,\n    ys::Union{AbstractRange{<:Real},Nothing}=nothing,\n    N::Integer,\n    distribution::PhaseSpaceDistribution)\n\nGenerates a MonteCarloSystem that produces a multidimensional histogram allowing to visualize the expected value of observables under PhaseSpaceDistribution distribution.\n\nSeveral behaviors can be produced.\n\nIf x is :t, a matrix of dimensions length(ts) times length(ys)  is produced. The coordinate (tᵢ,yⱼ) gives the probability of finding the observable y between ys[j] and ys[j+1] at the time ts[i].\nIf y is :t, the same as above, changing x by y.\nIf neither x nor y are :t, and animate = false, then a matrix of dimensions length(xs) times length(ys)  is produced.  The coordinate (xᵢ,yⱼ) gives the probability of finding the observable x between xs[i] and xs[i+1] and the observable y between ys[j] and ys[j+1], averaging over all the times in ts\nIf neither x nor y are t, and animate = true then an array of matrices of dimensions length(xs) times length(ys)  is produced, the same size as ts. For the nth matrix in this array, the coordinate (xᵢ,yⱼ) gives the probability of finding the observable x between xs[i] and xs[i+1] and the observable y between ys[j] and ys[j+1] at time ts[n].\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem,\nx and y can be :t, or an observable as described in the arguments of mcs_for_averaging.\nxs and ys should be given if  x and  y are not  :t, in wich case they should be range objects (e.g. 0:0.1:1) containing the bins for the histogram.\nts should be a range object (e.g. 0:0.1:1) of times.\nanimate should be a Bool, which determines the behavior if neither x nor y are t. Defaults to true\nN is the number of points to sample. The bigger the more accurate.\ndistribution should be an instance of PhaseSpaceDistribution\n\nNote: If ts and y are both not passed, then y is set to :t and ts to 0:0.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_for_survival_probability-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_for_survival_probability","text":"function mcs_for_survival_probability(\n    system::ClassicalSystems.ClassicalSystem;\n    N::Integer,\n    ts::AbstractArray{<:Real},\n    distribution::PhaseSpaceDistribution)\n\nGenerates a MonteCarloSystem that computes the survival probability through Eq. (C.7) of Ref. [9] (with M= N, w= distribution).\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem,\nts should be a sorted array of times.\nN is the number of points to sample. The bigger the more accurate.\ndistribution should be an instance of PhaseSpaceDistribution\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_for_variance-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_for_variance","text":"function mcs_for_variance(\n    system::ClassicalSystems.ClassicalSystem;\n    observable,\n    ts::AbstractVector{<:Real}=[0.0],\n    N::Integer,\n    distribution::PhaseSpaceDistribution,\n    return_average::Bool = false)\n\nGenerates a MonteCarloSystem that computes the variance\n\n    frac1N sum_i=1^N textobservable^2(mathbfx_i(t)) - left (frac1Nsum_i=1^N textobservable(mathbfx_i(t))right )^2\n\nfor each t in ts, where mathbfx_i will be sampled from distribution. The system produces an array the same size as ts, containing the result for each time.\n\nArguments\n\nSee arguments for mcs_for_averaging.\nIf return_average=false (default), only produces the variance, else it  will produce a tuple, where the first element is the variance and the second the average.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.monte_carlo_integrate-Tuple{Dicke.ClassicalSystems.ClassicalSystem, Dicke.TruncatedWignerApproximation.MonteCarloSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.monte_carlo_integrate","text":"function monte_carlo_integrate(system::ClassicalSystems.ClassicalSystem,\n    mc_system::MonteCarloSystem;\n    tolerate_errors=true,\n    maxNBatch=Inf,kargs...)\n\nThis function is the backbone of this module. It performs a Monte Carlo integration-type procedure. The argument mc_system determines a distribution::PhaseSpaceDistribution, an integer N, and a list of times ts. This function calls an initializing function also determined by mc_system. Then, it samples N random points x from distribution, which are integrated using the Hamiltonian given by system. For each trajectory and time in ts, an operation is performed, which is determined again by mc_system. A final operation is then performed and the result is returned. This may seem a bit abstract, but it is a very flexible system. The applications are more concrete; for example, if you generate mc_system using mcs_for_averaging(... observable=f ...),  then the initial operation is to generate an array of zeroes the same length as ts. Then, for each initial condition x, the result of f(x(t)) is added to each element of the array. Finally, the array is overall divided by N and then returned. This is exactly a Monte Carlo integration of the function f(x) over the classical evolution  of the distribution.\n\nThis function uses all the available workers, but make sure to import this module in all of them.\n\nArguments:\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem.\nmc_system should be an instance of  MonteCarloSystem.\ntolerate_errors indicates that some errors in the integration may be ignored. This is useful because sometimes a one-in-a-million numerical instability may arise, and you may want to ignore it. If more than 100 errors occur consecutively, then then the procedure is stopped. Defaults to true.\nmaxNBatch is the maximum number of batch-sizes sent to each worker. Defaults to inf.\nkargs are redirected to [ClassicalSystems.integrate].\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.survival_probability-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.survival_probability","text":"function survival_probability(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_survival_probability]]],\n    kargs...)\n\nCalls mcs_for_survival_probability and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.variance-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.variance","text":"function variance(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_variance]]],\n    kargs...)\n\nCalls mcs_for_variance and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl","page":"TruncatedWignerApproximation","title":"Weyl symbols","text":"","category":"section"},{"location":"TruncatedWignerApproximation/","page":"TruncatedWignerApproximation","title":"TruncatedWignerApproximation","text":"The submodule TruncatedWignerApproximation.Weyl generates classical phase-space observables that may be passed as the argument observable of average, calculate_distribution, etc. All the following functions SymEngine objects, so they may be operated as if they were numbers. ","category":"page"},{"location":"TruncatedWignerApproximation/","page":"TruncatedWignerApproximation","title":"TruncatedWignerApproximation","text":"Modules = [Dicke.TruncatedWignerApproximation.Weyl]\nOrder   = [:type,:function]","category":"page"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jx-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.Jx","text":"function Jx(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_x. (See p. 114 of Ref. [8])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jx²-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.Jx²","text":"function Jx²(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_x^2. (See bottom of p. 128 of Ref. [8])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jy-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.Jy","text":"function Jy(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_y. (See p. 114 of Ref. [8])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jy²-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.Jy²","text":"function Jy²(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_y^2. (See bottom of p. 128 of Ref. [8])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jz-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.Jz","text":"function Jz(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_z. (See p. 114 of Ref. [8])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jz²-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.Jz²","text":"function Jz²(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_z^2. (See bottom of p. 128 of Ref. [8])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.n-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.n","text":"function n(j::Real)\n\nReturns the Weyl symbol of the number operator W(n), (p²+  q² - ħ)/2, where ħ = 1/j.  \n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.n²-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.n²","text":"function n²(j::Real)\n\nReturns the Weyl symbol of the number operator squared W(n^2) = W(n)^2 - hbar^24, where hbar = 1j. (Note that the extra term hbar^24  appears due to the non-commutativity of q and p. See Ref. [7] for details on how to compute these expressions.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalLMG/#Dicke.ClassicalLMG","page":"ClassicalLMG","title":"Dicke.ClassicalLMG","text":"","category":"section"},{"location":"ClassicalLMG/","page":"ClassicalLMG","title":"ClassicalLMG","text":"Modules = [Dicke.ClassicalLMG]\nOrder   = [:function, :type]","category":"page"},{"location":"UPOS/#Dicke.UPOS","page":"UPOS","title":"Dicke.UPOS","text":"","category":"section"},{"location":"UPOS/","page":"UPOS","title":"UPOS","text":"Modules = [Dicke.UPOS]\nOrder   = [:function, :type]","category":"page"},{"location":"ClassicalDickeExamples/#Examples-for-ClassicalDicke","page":"Classical Dicke","title":"Examples for ClassicalDicke","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\nusing Dicke","category":"page"},{"location":"ClassicalDickeExamples/#Drawing-contours-of-the-available-phase-space","page":"Classical Dicke","title":"Drawing contours of the available phase space","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"We may use the function ClassicalDicke.minimum_ϵ_for to draw the contour of the available phase space on the variables (QP).","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"using Dicke.ClassicalDicke\nusing Plots\nsystem =  ClassicalDickeSystem(ω=1, γ=1, ω₀=1)\nQs = Ps = -2:0.01:2\nϵgs = minimum_energy(system)\ncontour(Qs, Ps,\n        (Q,P) -> minimum_ϵ_for(system, p=0, P=P, Q=Q),\n        levels=10, clim=(ϵgs,1), xlabel=\"Q\", ylabel=\"P\")\nsavefig(\"contourQP.svg\"); nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/#Plotting-the-density-of-states","page":"Classical Dicke","title":"Plotting the density of states","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"Here is a plot of the semiclassical density of states","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"using Dicke.ClassicalDicke\nusing Plots\nsystem = ClassicalDickeSystem(ω=1, γ=1, ω₀=1)\nν(ϵ) = density_of_states(system, j=100, ϵ=ϵ)\nϵgs = minimum_energy(system)\nplot(ν, ϵgs, 2, xlabel=\"ϵ\", ylabel=\"Density of States\")\nplot!(key=false) #hide\nsavefig(\"density_of_states.svg\"); nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"This is precisely the red line in Fig. A1. of Ref. [9].","category":"page"},{"location":"ClassicalDickeExamples/#Drawing-a-Poincaré-surface","page":"Classical Dicke","title":"Drawing a Poincaré surface","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"Here is a way to draw a Poincaré surface for the Dicke model. We use ClassicalSystems.integrate to integrate a bunch of initial conditions. Using the callback system of DifferentialEquations, we save the points where p=0.","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"using Dicke, Dicke.ClassicalDicke, Dicke.ClassicalSystems\nusing Plots\nusing DiffEqBase\n\nsystem=ClassicalDickeSystem(ω=0.8,γ=0.8,ω₀=1)\nmplot=scatter(fmt=:png, key=false, markersize=1, legend=false,\n    size=(500,500), color_palette=:darkrainbow, xlabel=\"Q\", ylabel=\"P\") \n\npts = Tuple{Float64, Float64}[] #a list of points (Q,P)\nfunction save(state) #this function saves (Q,P) to pts if q = q₊ (and not q₋).\n    if q_sign(system,state.u,ϵ) == + \n        Q,q,P,p = state.u \n        push!(pts, (Q,P))  \n    end                     \nend\ncallback=ContinuousCallback((x, t, _) -> x[4], #when p=x[4] is 0,\n    save; #execute the function save\n    save_positions=(false,false), abstol=1e-3)\nϵ = -1.35\nfor Q in 0:0.02:maximum_Q_for_ϵ(system, ϵ) #for a bunch of initial Qs,\n        if minimum_ϵ_for(system, P=0, p=0, Q=Q) > ϵ\n            continue\n        end\n        initial_condition = Point(system, ϵ=ϵ, P=0, p=0, Q=Q)\n        integrate(system, u₀=initial_condition,\n            t=10000, callback=callback, save_everystep=false)\n        scatter!(pts)\n        empty!(pts)\n        if !on_github break end #hide\n\n\nend\nmplot\nsavefig(\"poincare_surface.png\");nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/#Drawing-a-Lyapunov-exponent-map","page":"Classical Dicke","title":"Drawing a Lyapunov exponent map","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"Let us plot the Lyapunov exponents for the Poincaré map of the previous example.","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"using Dicke, Dicke.ClassicalDicke, Dicke.ClassicalSystems\nusing Plots\nusing DiffEqBase\n\nsystem = ClassicalDickeSystem(ω=0.8, γ=0.8, ω₀=1)\nϵ = -1.35\n\nresolution = 0.01 #making this smaller will make a smoother plot,\n                  #but it may take time!\nif !on_github resolution = 0.5 end #hide\n\nmaxQ = maximum_Q_for_ϵ(system,ϵ) \nmaxP = maximum_P_for_ϵ(system,ϵ) \n\nQs = 0.6:resolution:maxQ\nPs = 0.0:resolution:maxP  #we only compute the top half of \n                          #the plane, and later mirror it\n\n#this matrix contains NaNs (outside of bounds) and tuples [λ,n] \n#(inside of bounds), where λ is an average of all the Lyapunov \n#exponents of the n trajectories that have passed through that square\nmatrix = [if minimum_ϵ_for(system, P=P, p=0, Q=Q) > ϵ \n            NaN else [0.0,0] end \n                for Q in Qs, P in Ps] \n\npts = Tuple{Float64, Float64}[] #a list of points (Q,P) for temporary storage\n\nfunction save(state) #this function saves (Q,P) to pts if q = q₊ (and not q₋).\n    if q_sign(system,state.u,ϵ) == + \n        Q,q,P,p = state.u \n        push!(pts, (Q,P))  \n    end                     \nend\ncallback=ContinuousCallback((x, t, _) -> x[4], #when p=x[4] is 0,\n    save; #execute the function save\n    save_positions=(false,false), abstol=1e-3)\n#an auxiliary function, which gives the index k so that r[k] ≥ v >r[k]\nfunction index_of_subinterval(v,r) \n    if r[end] <v\n        return length(r)\n    end\n    if v < r[1] \n        return 1\n    end\n    return Int(round(((v-r[1])/(r[end]-r[1]))*(length(r)-1) +1))\nend\n#we iterate over the matrix and the values of Q,P\nfor ((Q,P),element) in zip(Iterators.product(Qs,Ps),matrix)\n    #if we are out of bounds or we have information on this Lyapunov exponent,\n    if element===NaN || element[2] > 0 \n        continue #we skip\n    end\n    \n    #the following 4 lines will populate pts with all the points (mQ,mP) in the \n    #Poincaré map that the trajectory starting at (Q,P) passes through.\n    empty!(pts)\n    push!(pts,(Q,P))\n    point  = Point(system, Q=Q, P=P, p=0, ϵ=ϵ)\n    λ = lyapunov_exponent(system, \n        t = 5000, \n        u₀ = point, \n        verbose = false, #hide\n        tol=if !on_github 1e-3   else 1e-12 end, #hide\n        callback = callback)\n    \n    \n    for (mQ,mP) in pts\n        #we save the Lyapunov into all of the squares that the trajectory visited.\n        el = matrix[index_of_subinterval(mQ,Qs),index_of_subinterval(abs(mP),Ps)]\n        #if we are inside bounds\n        if el !== NaN\n           \n            el[1] = (el[1]*el[2] + λ)/(el[2] + 1)  #we update the average\n            el[2] += 1 #we update the count\n        end\n    end\n    if !on_github break end #hide\nend\n\nmat=transpose([v[1] for v in matrix]) #we take the average Lyapunovs, and transpose\n#because heatmap takes transposed matrices.\n\nmat=vcat(mat[end:-1:2,1:end], mat) #mirror in P\nPs=vcat(-Ps[end:-1:2], Ps) #update Ps with negative values\n\nheatmap(Qs, Ps, mat, xlabel=\"Q\", ylabel=\"P\", size=(550,500))\nsavefig(\"lyapunov_map.svg\");nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"It looks very similar to the Poincaré map of the previous example! Notice how there are regular (black) and chaotic (colored) regions.","category":"page"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces","page":"PhaseSpaces","title":"Dicke.PhaseSpaces","text":"","category":"section"},{"location":"PhaseSpaces/","page":"PhaseSpaces","title":"PhaseSpaces","text":"Modules = [Dicke.PhaseSpaces]\nOrder   = [:function, :type]","category":"page"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke","page":"ClassicalDicke","title":"Dicke.ClassicalDicke","text":"","category":"section"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"Modules = [Dicke.ClassicalDicke]\nOrder   = [:function, :type]","category":"page"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.Point-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.Point","text":"function Point(system::ClassicalSystems.ClassicalSystem;Q,P,p,ϵ,signo::Union{typeof(-),typeof(+)}=+)\n\nReturns a list [Q,q,P,p], where q is calculated with ClassicalDicke.q_of_ϵ. See that function for details on the arguments. If there are no solutions for q, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.Pointθϕ-Tuple{}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.Pointθϕ","text":"function Pointθϕ(;θ,ϕ,q,p)\n\nReturns a list [Q,q,P,p], where Q and P are calculated from θ and ϕ using PhaseSpaces.Q_of_θϕ and  PhaseSpaces.P_of_θϕ.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.density_of_states-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.density_of_states","text":"function density_of_states(system::ClassicalDickeSystem;j,ϵ)\n\nReturns the semiclassical density of states (DoS) ν(ϵ), in units of 1ϵ. This is computed with an expression similar to Eq. (19) of Ref. [1], where we add an additional factor of j to have units of 1ϵ instead of 1E, and the integral is performed with a change of variable.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nj is the value of j\nϵ is the scaled energy ϵ=Ej\n\nSee Plotting the density of states for an example.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.discriminant_of_q_solution-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.discriminant_of_q_solution","text":"function discriminant_of_q_solution(system::ClassicalDickeSystem; Q,P,p,ϵ)\n\nReturns the discriminant of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nwhere h_textcl is given by Eq. (5) of Ref. [5].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nQ, P, p, and ϵ are the values of Q, P, p, and epsilon, respectively.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.energy_shell_volume-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.energy_shell_volume","text":"function energy_shell_volume(system::ClassicalDickeSystem;ϵ)\n\nReturns the volume of the classical energy shell in the phase space, that is, mathcalV(mathcalM_ϵ) in Eq. (27) of Ref. [4].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nϵ is the scaled energy ϵ=Ej\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.energy_width_of_coherent_state-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem, Any, Real}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.energy_width_of_coherent_state","text":"function energy_width_of_coherent_state(system::ClassicalDickeSystem,x,j::Real)\n\nReturns the energy width sigma of the coherent state left  mathbfxright rangle, in units of epsilon. This quantity is given by sigma_Dj with sigma_D as in App. A of Ref. [3].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nx is the coordinate mathbfx of the coherent state in the format [Q,q,P,p].\nj is the value of j.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.hamiltonian-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.hamiltonian","text":"function hamiltonian(system::ClassicalDickeSystem)\n\nReturns a classical Hamiltonian function h(x) where x=[Q,q,P,p], which is given by Eq. (5) of Ref. [5].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.maximum_P_for_ϵ-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.maximum_P_for_ϵ","text":"function maximum_P_for_ϵ(system::ClassicalDickeSystem,ϵ)\n\nComputes the maximum value of the parameter P accessible to the system at energy epsilon.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nϵ is the scaled energy ϵ=Ej.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.maximum_Q_for_ϵ-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.maximum_Q_for_ϵ","text":"function maximum_Q_for_ϵ(system::ClassicalDickeSystem,ϵ)\n\nSee ClassicalDicke.maximum_P_for_ϵ.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.minimum_energy-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.minimum_energy","text":"function minimum_energy(system::ClassicalDickeSystem)\n\nReturns the energy of the ground-state coordinate given by ClassicalDicke.minimum_energy_point.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\n\nNote: This function currently only works for the supperadiant phase.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.minimum_energy_point","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.minimum_energy_point","text":"function minimum_energy_point(system::ClassicalDickeSystem,Qsign::Union{typeof(-),typeof(+)}=+)\n\nReturns the ground-state coordinate, that is, mathbfx_textGS below Eq. (7) of Ref. [5].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nQsign toggles the sign of the Q coordinate, that is, + for mathbfx_textGS and  - for widetildemathbfx_textGS.\n\nNote: This function currently only works for the superradiant phase.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.minimum_ϵ_for-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.minimum_ϵ_for","text":"function minimum_ϵ_for(system::ClassicalDickeSystem;Q=:nothing,q=:nothing,P=:nothing,p=:nothing)\n\nReturns the minimum energy epsilon when constraining the system to three fixed values of the coordinates Q, q, P, p.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nYou may pass either (QqP) or (qPp). The other combinanations are not implemented.\n\nThis function can be especially useful to draw contours of the available phase space (see Drawing contours of the available phase space)\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.normal_frequency","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.normal_frequency","text":"function normal_frequency(system::ClassicalDickeSystem,signo::Union{typeof(-),typeof(+)}=+)\n\nReturns the ground-state normal frequency, that is, Omega_epsilon_textGS^AB at the bottom of page 3 of Ref. [5].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nsigno is - for Omega^A and + for Omega^B.\n\nNote: This function currently only works for the supperadiant phase.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.phase_space_dist_squared-Tuple{Any, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.phase_space_dist_squared","text":"function phase_space_dist_squared(x,y)\n\nReturns the phase-space distance d_mathcalM(mathbfxmathbfy) (See App. C of Ref [5]), where x and y are in the form [Q,q,P,p].\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.q_of_ϵ-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.q_of_ϵ","text":"function q_of_ϵ(system::ClassicalDickeSystem;Q,P,p,ϵ,signo::Union{typeof(-),typeof(+)}=+,returnNaNonError=true)\n\nReturns the solutions q_pm of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nwhere h_textcl is given by Eq. (5) of Ref. [5].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nQ, P, p, and ϵ are values of Q, P, p, and epsilon, respectively.\nsigno is + for q_+ and - for q_-\nIf returnNaNonError is true, then NaN is returned if there are no solutions. If it is false, and error is raised.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.q_sign","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.q_sign","text":"function q_sign(system::ClassicalDickeSystem,x,ϵ=hamiltonian(system)(x))\n\nReturns the sign of the root of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nThat is, this function returns + if q=x[2] ≈ q_of_ϵ(system;Q=x[1],P=x[3],p=x[4],ϵ=ϵ,signo=+) and returns - if q=x[2] ≈ q_of_ϵ(system;Q=x[1],P=x[3],p=x[4],ϵ=ϵ,signo=-).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nx is a vector in the form [Q,q,P,p].\nϵ should be the energy of x. If this is not passed, it is computed using hamiltonian(system). \n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.ClassicalDickeSystem","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.ClassicalDickeSystem","text":"struct ClassicalDickeSystem <: ClassicalSystems.ClassicalSystem\n\nInstance of ClassicalDicke.ClassicalDickeSystem which represents the classical Dicke model with the given parameters ω_0, ω, and γ. See Eq. (5) of Ref. [5]. To generate this struct, use the constructor\n\nClassicalDickeSystem(;ω₀::Real,ω::Real,γ::Real)\n\nFor example, system = ClassicalDickeSystem(;ω₀=1, ω=1, γ=1).\n\nThis struct may be passed to all functions in this module that require an instance of ClassicalDicke.ClassicalDickeSystem, as well as functions in other modules that require the abstract ClassicalSystems.ClassicalSystem,  such as  ClassicalSystems.integrate.\n\n\n\n\n\n","category":"type"},{"location":"DickeBCE/#Dicke.DickeBCE","page":"DickeBCE","title":"Dicke.DickeBCE","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"Modules = [Dicke.DickeBCE]\nOrder   = [:function, :type]","category":"page"},{"location":"DickeBCE/#Dicke.DickeBCE.H_BCE-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.H_BCE","text":"function H_BCE(system::QuantumSystem)\n\nReturns a sparse matrix corresponding to the Dicke Hamiltonian (see any of the references. For example, Eq. (1) of [6]) in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Jx-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.Jx","text":"function Jx(system::QuantumSystem)\n\nReturns a sparse matrix representing the operator hatJ_x in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Jz-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.Jz","text":"function Jz(system::QuantumSystem)\n\nReturns a sparse matrix representing the operator hatJ_z in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.diagonalization-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.diagonalization","text":"function diagonalization(systemQ::QuantumSystem;\n        load_cache = true,\n        save_cache = true,\n        cache_folder = joinpath(homedir(),\"dicke_diagonalizations\"),\n        maxϵ::Real = 5.0,\n        onlyload::Union{AbstractVector{<:Integer},Nothing} = nothing,\n        only_eigenenergies = false,\n        converged_tolerance=1e-3)\n\nIf load_cache = false or there are no saved diagonalizations in cache_folder, diagonalizes the Dicke Hamiltonian up to a maximum energy maxϵ. These eigenstates  are guaranteed to be converged, with a tolerance determined by converged_tolerance. Numerical degeneracies are also corrected, to ensure that the eigenstates have parity +1 or -1. If only_eigenenergies is false (default), a tuple (eigenenergies,eigenstates) is returned, where eigenenergies is real vector containing the eigenenergies and eigenstates is a real matrix that contains the eigenstates as columns. \n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\nload_cache is a boolean indicating whether to try to load from cache folder. Defaults to true.\nsave_cache determines if the results of a computed diagonalization are saved to the cache folder. Defaults to true.\ncache_folder is the cache folder where diagonalizations are saved. Default is %HOME%/dicke_diagonalizations\nmaxϵ is the maximum energy up to which we diagonalize. Keep this number  higher than the maximum converged regime you want.\nonlyload may be a vector of integers, indicating the indices of the eigenstates to load, or the default value, nothing, indicates that all eigenstates should be loaded.\nonly_eigenenergies should be true if you only to load the eigenenergies. Defaults to false (return eigenstates and eigenenergies).\nconverged_tolerance determines how strict we are in saying that an eigenstate is converged. The default value 1e-3 is usually the best.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.eigenenergies-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.eigenenergies","text":"function eigenenergies(systemQ::QuantumSystem;args...)\n\nReturns a vector containing the eigenenergies of the system. These are loaded or computed as in diagonalization. \n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\nargs... same as in diagonalization).\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.eigenstate_parities-Tuple{Dicke.DickeBCE.QuantumSystem, Any}","page":"DickeBCE","title":"Dicke.DickeBCE.eigenstate_parities","text":"function eigenstate_parities(system::QuantumSystem,eigenstates)\n\nReturns a vector of -1s and 1s contaning the parities of all of the eigenstates.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\neigenstates is the matrix of eigenstates. (See  diagonalization).\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.factor_R_of_coherent_state-Tuple{Dicke.DickeBCE.QuantumSystem, Any}","page":"DickeBCE","title":"Dicke.DickeBCE.factor_R_of_coherent_state","text":"function factor_R_of_coherent_state(system::QuantumSystem,\n    x;\n    eigenstates,\n    eigenenergies,\n    state = coherentBCE(system,x))\n\nComputes R for a coherent state, as defined in Eq. (30) of [9].\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\nx is an array [Q,q,P,p] representing the center of the coherent state.\neigenstates should be a matrix containing the eigenstates as columns.\neigenenergies  is a list containing the eigenenergies.\nstate is a complex vector representing the coherent state left  mathbfx right rangle. If it is not passed, it is computed using DickeBCE.coherentBCE\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.participation_ratio-Tuple{Any}","page":"DickeBCE","title":"Dicke.DickeBCE.participation_ratio","text":"function participation_ratio(state;eigenstates,eigenenergies=nothing,count_degeneracies=eigenenergies!=nothing,degentol=1e-5)\n\nReturns the Participation Ratio (PR) of state in the eigenbasis. If count_degeneracies is true, then Eq. (7) of [9] is used. If count_degeneracies is false, then the inverse of Eq. (19) of [9] is used.\n\nArguments:\n\nstate should be a complex vector representing the state in the efficient coherent basis.\neigenstates should be a matrix containing the eigenstates.\neigenenergies should be passed if count_degeneracies is  true. It is a list containing the eigenenergies.\ncount_degeneracies – whether to modify the PR definition to account for degeneracies (see above).  Default is false if eigenenergies is not passed, else it is true.\ndegentol minimum energy separation below which two eigenstates are considered degenerate. Default is 1e-5.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.survival_probability-Tuple{Union{Real, AbstractArray{var\"#s140\", N} where {var\"#s140\"<:Real, N}}}","page":"DickeBCE","title":"Dicke.DickeBCE.survival_probability","text":"function survival_probability(t::Union{Real,AbstractArray{<:Real}};\n    state,\n    eigenstates,\n    eigenenergies,\n    normwarning=0.99)\n\nPENDING\n\nArguments:\n\nPENDING\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Π_BCE-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.Π_BCE","text":"function Π_BCE(system::QuantumSystem)\n\nReturns a sparse matrix corresponding to the parity operator hatPi=e^ipi(hata^daggerhata+ hatJ_z + j) in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.QuantumSystem","page":"DickeBCE","title":"Dicke.DickeBCE.QuantumSystem","text":"mutable struct QuantumSystem\n\nThis object represents the quantum Dicke model. It stores the parameters of the system, and it may be passed to multiple functions in this module. To generate a QuantumSystem, use QuantumSystem.\n\n\n\n\n\n","category":"type"},{"location":"DickeBCE/#Dicke.DickeBCE.QuantumSystem-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.QuantumSystem","text":"function QuantumSystem(system::ClassicalDicke.ClassicalDickeSystem;j,Nmax=nothing)\n\nReturns a  QuantumSystem given j, N_textmax, ω_0, ω, and γ. \n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nj is the value of j.\nNmax is the maximum excitation of the modified bosonic sector in the efficient coherent basis (see [2]). It may be omitted if there is a saved diagonalization.  In that case, a call to diagonalization will populate this value with the  greatest available in the saved cache.    \n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems","page":"ClassicalSystems","title":"Dicke.ClassicalSystems","text":"","category":"section"},{"location":"ClassicalSystems/","page":"ClassicalSystems","title":"ClassicalSystems","text":"Modules = [Dicke.ClassicalSystems]\nOrder   = [:function, :type]","category":"page"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.integrate-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.integrate","text":"function integrate(system::ClassicalSystem;t::Real,\n                   u₀::AbstractArray{<:Real, 1},\n                   t₀=0.0::Real,\n                   tol=1e-12::Real,\n                   get_fundamental_matrix::Bool=false,\n                   integrator_alg=TsitPap8(),\n                   use_big_numbers::Bool=false,\n                   integate_backwards::Bool=false,\n                   kargs...)\n\nThis function integrates initial condition u₀ from t₀ to t under the Hamiltonian system determined by system, returning an instance of ODESolution from the     package DifferentialEquations (See https://diffeq.sciml.ai/dev/basics/solution/).\n\nArguments:\n\nsystem is an instance of ClassicalSystems.ClassicalSystem.\nu₀ is an array which codifies the initial condition [Q,q,P,p] for ClassicalDicke and [Q,P] for ClassicalLMG.\nt is the start time of the integration.\nt₀ is the start of the integration (defaults to t₀ = 0.0) ClassicalSystems.ClassicalSystem.\ntol is the tolerance for the integration, which determines both abstol and reltol in https://diffeq.sciml.ai/stable/basics/commonsolveropts/\nget_fundamental_matrix determines whether to also compute the fundametal matrix of the system. If true, the result at each time is an ArrayPartition(x,Φ), so that x=result.x[2] retrieves the coordinate and Ψ=result.x[2] retrieves the fundamental matrix. Default is false. Note that the integration is consideribly slowed down if this parameter is set to true.\nintegrator_alg is the integration algorithm to use. Defaults to TsitPap8 (Tsitouras-Papakostas 8/7 Runge-Kutta method). See https://diffeq.sciml.ai/stable/solvers/ode_solve/#Full-List-of-Methods for other options.\nuse_big_numbers forces the integration to be performed with BigFloat instead of Float, allowing for infinite numerical precision, but hindering speed substantially. Defaults to false.\nintegate_backwards tells the integrator to integrate back in time, from -t₀ to -t. Defaults to  false.\nAdditional kargs are passed to OrdinaryDiffEq.solve (see https://diffeq.sciml.ai/stable/basics/commonsolveropts/).\n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.lyapunov_exponent-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.lyapunov_exponent","text":"function lyapunov_exponent(system::ClassicalSystem;kargs...)\n\nReturns the maximal Lyapunov exponent for system.\n\nArguments\n\nsystem is an instance of ClassicalSystems.ClassicalSystem.\nkargs... are redirected to ClassicalSystems.integrate. In particular, you should pass u₀. The value t is set to 10000 but you may change it: lower values increase speed, higher values increase precision. \n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.lyapunov_spectrum-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.lyapunov_spectrum","text":"function lyapunov_spectrum(system::ClassicalSystem;kargs...)\n\nSame as ClassicalSystems.lyapunov_exponent, but returns the whole Lyapunov spectrum.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.ClassicalSystem","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.ClassicalSystem","text":"abstract struct ClassicalSystem\n\nThis abstract object represents a classical system that may be passed to multiple functions in this module. To generate a system, use the subtypes ClassicalDicke.ClassicalDickeSystem or use ClassicalLMG.ClassicalLMGSystem.\n\n\n\n\n\n","category":"type"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"This package is a result of more than two years of investigation of the Dicke Model. It contains numerical methods that were used in the following publications:","category":"page"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"Quantum localization measures in phase space.  Physical Review E 103 052214 (2021) DOI: 10.1103/physreve.103.052214\nUbiquitous quantum scarring does not prevent ergodicity.  Nature Communications 12 852 (2021) DOI: 10.1038/s41467-021-21123-5\nQuantum scarring in a spin-boson system: fundamental families of periodic orbits.  New Journal of Physics 23 033045 (2021) DOI: 10.1088/1367-2630/abd2e6\nQuantum vs classical dynamics in a spin-boson system: manifestations of spectral correlations and scarring.  New Journal of Physics 22 063036 (2020) DOI: 10.1088/1367-2630/ab8ef8\nPositive quantum Lyapunov exponents in experimental systems with a regular classical limit.  Physical Review E 101 010202(R) (2020) DOI: 10.1103/PhysRevE.101.010202","category":"page"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"It is split into several submodules:","category":"page"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"ClassicalDicke allows to compute classical dynamics of the Dicke model, including a wide range of semiclassical aproximations to quantum properties.\nClassicalSystems provides a general framework for computing classical Hamiltonian dynamics, inlcuding Lyapunov exponents. It is mostly used for the Dicke model, but in principle it can be expanded to other Hamiltonians.\nDickeBCE provides multiple functions for analyzing the quantum Dicke model. It uses an efficient basis known as the Efficient Coherent Basis (BCE). See Refs. above.\nUPOS contains a set of functions to find unstable periodic orbits (UPOs) in the classical Dicke model. (See Ref. 3)\nTruncatedWignerApproximation allows to perform semiclassical calculations using the truncated Wigner approximation (TWA). (See Refs 2,5)\nDickeHusimiProjections contains a set of functions to integrate functions over the classical energy shells of the Dicke Model. It also contains specialized functions to compute these integrals for the Husimi functions of quantum states, which define phase-space localization measures known as Rényi occupations (See Refs. 1 and 2)\nClassicalLMG provides very basic functions for the classical Lipkin-Meshkov-Glick model. (See Ref. 5)\nPhaseSpaces provides some canonical transformations of the Bloch-Sphere.","category":"page"}]
}
