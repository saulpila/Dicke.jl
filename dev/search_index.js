var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"UPOs/#DickeModel.UPOs","page":"UPOs","title":"DickeModel.UPOs","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"For examples of usage, go to  Examples for UPOs.","category":"page"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"CurrentModule = DickeModel.UPOs","category":"page"},{"location":"UPOs/#Periodic-Orbit-(PO)-type","page":"UPOs","title":"Periodic Orbit (PO) type","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"PO\nPO(::DickeSystem, ::AbstractVector{<:Real})\nBase.:(==)(::PO,::PO)\nBase.in(::AbstractVector{<:Number},::PO)","category":"page"},{"location":"UPOs/#DickeModel.UPOs.PO","page":"UPOs","title":"DickeModel.UPOs.PO","text":"struct PO\n\nThis struct represents a periodic orbit in the classical Dicke model. To generate, use \n\npo = PO(system, u, T)\n\nwhere system is an instance of ClassicalDicke.DickeSystem, u is a real vector of an initial condition in the form [Q,q,P,p], and T is a real number representing the period. You can retrieve this values using po.system, po.u, and po.T.\n\n\n\n\n\n","category":"type"},{"location":"UPOs/#DickeModel.UPOs.PO-Tuple{DickeModel.ClassicalDicke.DickeSystem, AbstractVector{var\"#s25\"} where var\"#s25\"<:Real}","page":"UPOs","title":"DickeModel.UPOs.PO","text":"function PO(system::DickeSystem, u::AbstractVector{<:Real})\n\nGenerates a PO, given a periodic condition u = [Q,q,P,p], where  the period is calculated using approximate_period(system,u,bound=1e-2).\n\n\n\n\n\n","category":"method"},{"location":"UPOs/#Base.:==-Tuple{DickeModel.UPOs.PO, DickeModel.UPOs.PO}","page":"UPOs","title":"Base.:==","text":"Base.:(==)(po1::PO,po2::PO;Ttol::Real=1e-5,tol::Real=1e-6)\n\nThe comparison po1 == po2 returns true if po1 and po2 represent the same periodic orbit, regardless of which initial condition they have. This is done by evaluating ∈(po1.u,  po2, tol = tol) && abs(po1.T-po2.T) < Ttol\n\n\n\n\n\n","category":"method"},{"location":"UPOs/#Base.in-Tuple{AbstractVector{var\"#s25\"} where var\"#s25\"<:Number, DickeModel.UPOs.PO}","page":"UPOs","title":"Base.in","text":"Base.in(u::AbstractVector{<:Number}, po::PO;tol::Real=1e-6)\nBase.∈(u::AbstractVector{<:Number}, po::PO;tol::Real=1e-6)\n\nYou may write u ∈ po.\n\nReturns true if the point u is part of the periodic orbit po. This is done by integrating po.u and seeing if it comes within tol of u.\n\n\n\n\n\n","category":"method"},{"location":"UPOs/#Integrals-over-POs","page":"UPOs","title":"Integrals over POs","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"integrate(::PO)\naverage_over_PO\naverage_over_PO_QP\naverage_over_PO_qp","category":"page"},{"location":"UPOs/#DickeModel.ClassicalSystems.integrate-Tuple{DickeModel.UPOs.PO}","page":"UPOs","title":"DickeModel.ClassicalSystems.integrate","text":"function integrate(po::PO;tol::Real=1e-16, kargs...)\n\nReturns an instance of OrdinaryDiffEq.ODESolution, resulting from integrating po.u from t = 0 to t = po.T. \n\nArguments\n\npo should be an instance of PO.\n\nKeyword arguments\n\ntol is a real number indicating the precision for the integrator. Defaults to 1e-16.\nkargs are redirected to ClassicalSystems.integrate.\n\n\n\n\n\n","category":"method"},{"location":"UPOs/#DickeModel.UPOs.average_over_PO","page":"UPOs","title":"DickeModel.UPOs.average_over_PO","text":"function average_over_PO(po::Union{OrdinaryDiffEq.ODESolution,PO},\n    f::Function;\n    kargs...)\n\nComputes the average of a function f over the periodic orbit po\n\n    frac1T int_0^T f(u(t))  textd t\n\nwhere T= po.T and u= po.u.\n\nArguments\n\npo should be an instance of PO or an instance of OrdinaryDiffEq.ODESolution, in which case the integration is ommited.\nf should be a function with a method f([Q,q,P,p]), which returns values that may be added together and multiplied by scalars (e.g. numbers or arrays).\n\nKeyword arguments\n\nkargs are redirected to  ClassicalSystems.integrate.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.average_over_PO_QP","page":"UPOs","title":"DickeModel.UPOs.average_over_PO_QP","text":"function average_over_PO_QP(po::Union{OrdinaryDiffEq.ODESolution,PO},\n    f::Function;\n    kargs...)\n\nSame as average_over_PO, but f only depends on Q,P, that is, the signature of f is f(Q,P).\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.average_over_PO_qp","page":"UPOs","title":"DickeModel.UPOs.average_over_PO_qp","text":"function average_over_PO_qp(po::Union{OrdinaryDiffEq.ODESolution,PO},\n    f::Function;\n    kargs...)\n\nSame as average_over_PO, but f only depends on q,p, that is, the signature of f is f(q,p).\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#Properties-of-POs","page":"UPOs","title":"Properties of POs","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"action\njx_PO_average\njy_PO_average\njz_PO_average\nlyapunov\nenergy","category":"page"},{"location":"UPOs/#DickeModel.UPOs.action","page":"UPOs","title":"DickeModel.UPOs.action","text":"function action(po::PO;kargs...)\n\nNumerically computes the action\n\n    S = int ptextd q + P  textd Q\n\nalong the periodic orbit po.\n\nArguments\n\npo should be an instance of PO\n\nKeyword arguments\n\nkargs are redirected to integrate\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.jx_PO_average","page":"UPOs","title":"DickeModel.UPOs.jx_PO_average","text":"function jx_PO_average(po::Union{OrdinaryDiffEq.ODESolution,PO},\n    f::Function;\n    kargs...)\n\nReturns average_over_PO_QP(PO,PhaseSpaces.jx;kargs...).\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.jy_PO_average","page":"UPOs","title":"DickeModel.UPOs.jy_PO_average","text":"function jy_PO_average(po::Union{OrdinaryDiffEq.ODESolution,PO},\n    f::Function;\n    kargs...)\n\nReturns average_over_PO_QP(PO,PhaseSpaces.jy;kargs...).\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.jz_PO_average","page":"UPOs","title":"DickeModel.UPOs.jz_PO_average","text":"function jz_PO_average(po::Union{OrdinaryDiffEq.ODESolution,PO},\n    f::Function;\n    kargs...)\n\nReturns average_over_PO_QP(PO,PhaseSpaces.jz;kargs...).\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.lyapunov","page":"UPOs","title":"DickeModel.UPOs.lyapunov","text":"function lyapunov(po::PO)\n\nReturns the Lyapunov exponent of the periodic orbit po, as given by Eq. (B3) of Ref. [13].\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.energy","page":"UPOs","title":"DickeModel.UPOs.energy","text":"energy(po::PO) = ClassicalDicke.hamiltonian(po.system)(po.u)\n\nReturns the energy of the periodic orbit po.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#Operations-on-POs","page":"UPOs","title":"Operations on POs","text":"","category":"section"},{"location":"UPOs/#Mirror-operations","page":"UPOs","title":"Mirror operations","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"mirror_Qq\nmirror_Pp","category":"page"},{"location":"UPOs/#DickeModel.UPOs.mirror_Qq","page":"UPOs","title":"DickeModel.UPOs.mirror_Qq","text":"function mirror_Qq(po::PO)\n\nReturns a periodic orbit po1, which results from changing the sign of the Q and q coordinates of the periodic orbit po.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.mirror_Pp","page":"UPOs","title":"DickeModel.UPOs.mirror_Pp","text":"function mirror_Pp(po::PO)\n\nReturns a periodic orbit po1, which results from changing the sign of the P and p coordinates of the periodic orbit po.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#Coordinate-extraction","page":"UPOs","title":"Coordinate extraction","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"po_coordinates","category":"page"},{"location":"UPOs/#DickeModel.UPOs.po_coordinates","page":"UPOs","title":"DickeModel.UPOs.po_coordinates","text":"function po_coordinates(coords::AbstractArray{<:Integer}, \n    po::PO;tol::Real=1e-12)\n\nReturns an array [Tuple(x1[coords]), Tuple(x2[coords]), ...], where is an array containing up to 4 integers from 1 to 4, and xi are the points in po obtained with numerical  integration with tolerance tol.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"The following methods are shorthand implementations of po_coordinates. They are useful to plot a periodic orbit. For example, plot(QP(po)) plots the orbit in the  atomic plane.","category":"page"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"QP\nqp\nQPp\nQPq","category":"page"},{"location":"UPOs/#DickeModel.UPOs.QP","page":"UPOs","title":"DickeModel.UPOs.QP","text":"QP(po::PO; tol::Real=1e-12) = po_coordinates([1,3], po, tol=tol)\n\nReturns an array [(Q1, P1), (Q2, P2), ...] with the coordinates of po, integrated with tolerance tol. This can be directly passed to Plots.plot\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.qp","page":"UPOs","title":"DickeModel.UPOs.qp","text":"qp(po::PO; tol::Real=1e-12) = po_coordinates([2,4], po, tol=tol)\n\nReturns an array [(q1, p1), (q2, p2), ...] with the coordinates of po, integrated with tolerance tol. This can be directly passed to Plots.plot\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.QPp","page":"UPOs","title":"DickeModel.UPOs.QPp","text":"QPp(po::PO; tol::Real=1e-12) = po_coordinates([1,3,4], po, tol=tol)\n\nReturns an array [(Q1, P1, p1), (Q2, P2, p2), ...] with the coordinates of po, integrated with tolerance tol. This can be directly passed to Plots.plot to generate a 3D plot.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.QPq","page":"UPOs","title":"DickeModel.UPOs.QPq","text":"QPq(po::PO; tol::Real=1e-12) = po_coordinates([1,3,2], po, tol=tol)\n\nReturns an array [(Q1, P1, q1), (Q2, P2, q2), ...] with the coordinates of po, integrated with tolerance tol. This can be directly passed to Plots.plot to generate a 3D plot.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#Finding-POs","page":"UPOs","title":"Finding POs","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"approximate_period\nfind_p_zero","category":"page"},{"location":"UPOs/#DickeModel.UPOs.approximate_period","page":"UPOs","title":"DickeModel.UPOs.approximate_period","text":"function approximate_period(system::DickeSystem,\n    u₀::AbstractVector{<:Real};\n    bound::Real = 0.1,\n    tol::Real = 1e-8,\n    max_p_crossings::Real = Inf,\n    verbose::Bool = true)\n\nComputes the time necessary for the initial condition u₀ to come back to the same p-plane within a neighborhood of radius bound of u₀. This is useful to approximate the period of an almost periodic condition u₀. The maximum time  of integration is 10000.\n\nArguments\n\nsystem should be an instance of ClassicalDicke.DickeSystem.\nu₀ is a point [Q,q,P,p] in the phase space of the Dicke model.\n\nKeyword arguments\n\nbound is a positive real number indicating how close does the evolution has  to come back to u₀. Defaults to 0.1.\ntol is the integration tolerance. Not to be confused with bound. Defaults to  1e-8.\nmax_p_crossings is the maximum number of times the condition may cross the p plane before aborting. Defaults to Inf (no maximum).\nverbose is a boolean indicating whether to log information messages. Defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.find_p_zero","page":"UPOs","title":"DickeModel.UPOs.find_p_zero","text":"function find_p_zero(system::DickeSystem,\n    u₀::AbstractVector{<:Real};\n    tol::Real=1e-6,\n    negative::Bool=false)\n\nEvolves u₀ until it crosses the p=0 plane from negative to positive and returns the result.\n\nArguments\n\nsystem should be an instance of ClassicalDicke.DickeSystem.\nu₀ is a point [Q,q,P,p] in the phase space of the Dicke model.\n\nKeyword arguments\n\ntol is the numerical tolerance.\nIf negative is true, then the crossing is from positive to negative. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#Monodromy-methods","page":"UPOs","title":"Monodromy methods","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"monodromy_method_constant_period\nmonodromy_method_constant_energy","category":"page"},{"location":"UPOs/#DickeModel.UPOs.monodromy_method_constant_period","page":"UPOs","title":"DickeModel.UPOs.monodromy_method_constant_period","text":"function monodromy_method_constant_period(system::DickeSystem,\n    u₀::AbstractVector{<:Real},\n    T::Real;\n    maxiters::Integer=100,\n    tol::Real=1e-8,\n    inttol::Real=tol/10)\n\nReturns a PO with a given period T that is found by iteratively perturbating the initial condition u₀ in the direction that minimizes the distance between u_0 and u_0(T). The perturbation is obtained from Eq. (31) of Ref. [17], taking Lambda as the fundamental matrix evaluated at time T. Note that the energy of u₀ will change. To conserve the energy and vary T, use monodromy_method_constant_energy instead.\n\nArguments\n\nsystem should be an instance of ClassicalDicke.DickeSystem.\nu₀ is a point [Q,q,P,p] in the phase space of the Dicke model, which is used  as the starting point to find an orbit.\nT is a positive real number, indicating the desired period.\n\nKeyword arguments\n\nmaxiters is a integer which sets the maximum number of iterations. Defaults to 100.\ntol is a tolerance. If  u-u(T) tol, u is considered a periodic condition with period T. The smaller the tolerance, the more iterations are needed to converge. Default is 1e-8\ninttol is the tolerance to be passed to ClassicalSystems.integrate. Default is tol/10.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.monodromy_method_constant_energy","page":"UPOs","title":"DickeModel.UPOs.monodromy_method_constant_energy","text":"function monodromy_method_constant_energy(system::DickeSystem,\n    u₀::AbstractVector{<:Real},\n    T::Real;\n    maxiters::Integer=100,\n    tol::Real=1e-8,\n    inttol::Real=tol/10,\n    correct_energy::Bool=true)\n\nReturns a PO with energy approximatelly (see below) the same energy as u₀ obtained  by iteratively perturbating period T and the initial condition u₀  in the direction that minimizes the distance between u_0 and u_0(T) and is perpendicular to the Hamiltonian gradient. The algorithm is described in App. A, section A.1. of Ref. [13].\n\nArguments\n\nsystem should be an instance of ClassicalDicke.DickeSystem.\nu₀ is a point [Q,q,P,p] in the phase space of the Dicke model, which is used  as the starting point to find an orbit.\nT is a positive real number, which is used as the starting point to find an orbit.\n\nKeyword arguments\n\nmaxiters is a integer which sets the maximum number of iterations. Defaults to 100.\ntol is a tolerance. If  u-u(T) tol, u is considered a periodic condition with period T. The smaller the tolerance, the more iterations are needed to converge. Default is 1e-8\ninttol is the tolerance to be passed to ClassicalSystems.integrate. Default is tol/10.\ncorrect_energy is a Boolean. As described in  Ref. [13], this algorithm only approximately conserves energy. If correct_energy == true, the initial condition  is projected back to the energy shell between each iteration. This allows energy to be truly conserved, however, it makes the algorithm more unstable. The default is true. \n\n\n\n\n\n","category":"function"},{"location":"UPOs/#PO-familly-followers","page":"UPOs","title":"PO familly followers","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"follow_PO_family_from_period\nfollow_PO_family_from_energy\n\nfamily_A\nfamily_B","category":"page"},{"location":"UPOs/#DickeModel.UPOs.follow_PO_family_from_period","page":"UPOs","title":"DickeModel.UPOs.follow_PO_family_from_period","text":"function follow_PO_family_from_period(po::PO;\n    step::Real=0.1,\n    tol::Real=1e-5,\n    initalperturbation::AbstractVector{<:Real}=Float64[0,1,0,0],\n    verbose::Bool =true)\n\nReturns a function T -> po1 that returns a PO from the same family as po but with period T. This algorithm applies the function monodromy_method_constant_period repeatedly, increasing or decreasing the period in small perturbations to reach the target.\n\nArguments\n\npo should be an instance of PO\n\nKeyword arguments\n\nstep is the initial size of the perturbations in period, this is decreased and increased dynamically (default is 0.1).\ntol is the tolerance to pass to monodromy_method_constant_period (default is 1e-5).\nverbose is a Boolean indicating whether to print the progress. Default is true.\n\nThe function returned accepts the following keyword arguments:\n\ntol overrides tol above.\nminstep is the minimum step (which is varied dynamically). Default is step/1000.\nmaxstep is the maximum step. Default is step.\nstep overrides step above. Default is maxstep.\nmaxiters is the maximum number of iterations. Default is 1000.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.follow_PO_family_from_energy","page":"UPOs","title":"DickeModel.UPOs.follow_PO_family_from_energy","text":"function follow_PO_family_from_energy(po::PO;\n    step::Real=0.1,\n    tol::Real=1e-5,\n    energytol::Real=1e-3,\n    initalperturbation::AbstractVector{<:Real}=Float64[0,1,0,0],\n    verbose::Bool =true,\n    dontallowlessenergy::Bool=false)\n\nReturns a function ϵ -> po1 that returns a PO from the same family as po but with energy ϵ. This algorithm is detailed in App. A.2. of Ref. [13]\n\nArguments\n\npo should be an instance of PO.\n\nKeyword arguments\n\nstep is the initial size of the perturbations in energy, this is decreased and increased dynamically (default is 0.1). If the orbits seem to suddenly jump, try to decrease this number.\ntol is the tolerance to pass to monodromy_method_constant_energy (default is 1e-5).\nenergytol is the precision in energy below which a PO is returned   (default is 1e-3).\ninitalperturbation is de direction of the first perturbation in the form [Q,q,P,p] (default is [0,1,0,0]).\nverbose is a Boolean indicating whether to print the progress. Default is true.\ndontallowlessenergy forbids evaluation below the energy of po. Default is false.\n\nThe function returned accepts the following keyword arguments:\n\ntol overrides  tol above.\nenergytol overrides  energytol above.\nmaxstep is the maximum step. Default is step.\nstep overrides step above. Default is maxstep.\nminstep is the minimum step (which is varied dynamically). Default is min(step,energytol/10).\ncorrect_energy is passed to monodromy_method_constant_energy. Default is true.\nmaxiters is the maximum number of iterations. Default is 1000.\nenergywiggletolerance is the tolerance for oscillations. Oscillating behaviour indicates instability, but sometimes it happens and there must be some tolerance. The default is 1e-2.\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.family_A","page":"UPOs","title":"DickeModel.UPOs.family_A","text":"function family_A(system::DickeSystem;kargs...)\n\nReturns a function ϵ -> po that returns a PO from family mathcalA of Ref. [13]. This is done by passing the ground state fixed point with the positive normal frequency as period to follow_PO_family_from_energy.\n\nArguments\n\nsystem should be an instance of ClassicalDicke.DickeSystem.  The system must be in the supperradiant regime. \n\nKeyword arguments\n\nkargs... are redirected to follow_PO_family_from_energy\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.family_B","page":"UPOs","title":"DickeModel.UPOs.family_B","text":"function family_B(system::DickeSystem;kargs...)\n\nReturns a function ϵ -> po that returns a PO from family mathcalB of Ref. [13]. This is done by passing the ground state fixed point with the negative normal frequency as period to follow_PO_family_from_energy.\n\nArguments\n\nsystem should be an instance of ClassicalDicke.DickeSystem.  The system must be in the supperradiant regime. \n\nKeyword arguments\n\nkargs... are redirected to follow_PO_family_from_energy\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#Scarring-measure","page":"UPOs","title":"Scarring measure","text":"","category":"section"},{"location":"UPOs/","page":"UPOs","title":"UPOs","text":"scarring_measure\noverlap_of_tube_with_homogenous_state","category":"page"},{"location":"UPOs/#DickeModel.UPOs.scarring_measure","page":"UPOs","title":"DickeModel.UPOs.scarring_measure","text":"function scarring_measure(\n    po::PO{DickeBCE.QuantumDickeSystem},\n    quantum_state::AbstractVector{<:Number};\n    chop::Real=1e-3,\n    kargs...)\n\nReturns the scarring measure mathcalP(mathcalOhatrho) as defined in Eq. (17) of Ref. [13].\n\nArguments\n\npo should be an instance of PO representing mathcalO above. The system passed to create po should have been a QuantumDickeSystem.\nquantum_state should be a vector representing the quantum state  hatrho in the coherent efficient basis. \n\nKeyword arguments\n\nchop is the tolerance to be passed to DickeBCE.husimi (see the documentation of DickeBCE.coherent_overlap)\nkargs are redirected to overlap_of_tube_with_homogenous_state, which gives the denominator in Eq. (17) of Ref. [13].\n\n\n\n\n\n","category":"function"},{"location":"UPOs/#DickeModel.UPOs.overlap_of_tube_with_homogenous_state","page":"UPOs","title":"DickeModel.UPOs.overlap_of_tube_with_homogenous_state","text":"function overlap_of_tube_with_homogenous_state(po::PO{DickeBCE.QuantumDickeSystem};\n                                        time_integral_tolerance::Real=1e-7,\n                                        phase_space_integral_resolution::Real=0.1)\n\nReturns the overlap texttr(hatrho_epsilon hatrho_mathcalO ) of a tubular state hatrho_mathcalO around the periodic orbit mathcalO= po, (Eq. (15) of Ref. [13])  with a totally delocalized state hatrho_epsilon (Eq. (16) of Ref. [13]).\n\nArguments\n\npo should be an instance of PO. The system passed to create po  should have been a QuantumDickeSystem.\n\nKeyword arguments\n\ntime_integral_tolerance is the numerical tolerance for the integral in Eq. (15) of Ref. [13]. Default is 1e-7.\nphase_space_integral_resolution is the phase space resolution for the integral in Eq. (16) of Ref. [13], that is, res in EnergyShellProjections.energy_shell_average. Default is 0.1.\n\n\n\n\n\n","category":"function"},{"location":"EnergyShellProjections/#DickeModel.EnergyShellProjections","page":"EnergyShellProjections","title":"DickeModel.EnergyShellProjections","text":"","category":"section"},{"location":"EnergyShellProjections/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"For examples of usage, go to  Examples for EnergyShellProjections.","category":"page"},{"location":"EnergyShellProjections/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"CurrentModule = DickeModel.EnergyShellProjections","category":"page"},{"location":"EnergyShellProjections/#Integrals-of-arbitrary-functions","page":"EnergyShellProjections","title":"Integrals of arbitrary functions","text":"","category":"section"},{"location":"EnergyShellProjections/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"∫∫dqdpδϵ\nmatrix_QP∫∫dqdpδϵ\nenergy_shell_average","category":"page"},{"location":"EnergyShellProjections/#DickeModel.EnergyShellProjections.∫∫dqdpδϵ","page":"EnergyShellProjections","title":"DickeModel.EnergyShellProjections.∫∫dqdpδϵ","text":"function ∫∫dqdpδϵ(system::DickeSystem;\n    ϵ::Real,\n    Q::Real,\n    P::Real,\n    f::Function,\n    p_res::Real=0.01,\n    nonvalue=nothing,\n    onlyqroot::Union{typeof(-),typeof(+),Nothing}=nothing)\n\nComputes the integral  \n\n    int int textdq textdp f(mathbfx) delta(h_textcl(mathbfx) - epsilon)\n\nusing Eq. (8) of Ref. [14] and a  Chebyshev–Gauss quadrature method.  \n\nNote: to type ∫ in Julia, type \\int + Tab.\n\nArguments\n\nsystem should be an instance of ClassicalDicke.DickeSystem.\n\nKeyword arguments\n\nϵ is a real number corresponding to epsilon above.\nQ and P are the Q and P coordinates of mathbfx above.\nf should be function with signature f([Q,q,P,p]) that returns values that may be added together (e.g. numbers, arrays, etc...).\np_res is the resolution of the integral. The amount of nodes for the quadrature will be equal to 2*floor(p₊/p_res) + 1, where p₊ is defined below Eq. (9) of Ref. [14]. Default is 0.01.\nnonvalue is the value to return if QP are outside of the energy shell at epsilon. Default is NaN.\nonlyqroot may be +, -, or nothing (default). If it is + (-), the integral is only computed over the positive (negative) roots in q, that is, only the q_+ (q_-) term is taken in Eq. (8) of Ref. [14]. If it is nothing, both terms are added.\n\n\n\n\n\n","category":"function"},{"location":"EnergyShellProjections/#DickeModel.EnergyShellProjections.matrix_QP∫∫dqdpδϵ","page":"EnergyShellProjections","title":"DickeModel.EnergyShellProjections.matrix_QP∫∫dqdpδϵ","text":"function matrix_QP∫∫dqdpδϵ(system::DickeSystem;\n    f::Function,\n    ϵ::Real,\n    res::Real=0.1,\n    symmetricQP::Bool=false,\n    symmetricP::Bool=symmetricQP,\n    parallelize::Bool=(Distributed.myid()==1),\n    show_progress::Bool = true,\n    pbatch_size::Integer=Int(min(ceil((4/res)^2/Distributed.nprocs()/10),50)))\n\nReturns  a tuple (Qs, Ps, mat) where Qs and Ps are real vectors spanning all possible values of P and Q with some step res, and mat  is a matrix whose entries are given by mat[i,j] =∫∫dqdpδϵ(system; kargs..., ϵ=ϵ, Q=Qs[i], P=P[j], p_res=res)\n\nArguments\n\nsystem should be an instance of ClassicalDicke.DickeSystem.\n\nKeyword arguments\n\nϵ is a real number (see arguments for ∫∫dqdpδϵ).\nf should be function with signature f([Q,q,P,p]) that returns values that may be added together (e.g. numbers, arrays, etc...).\nres determines the separation between the elements of Qs and Ps. It also determines p_res in the calls to ∫∫dqdpδϵ. It should be a positive real number that is an integer fraction of 2 (i.e. 2n for some n in mathbbN). Computation time is inversely proportional to the cube of this quantity.\nIf symmetricQP is true, only the non-positive entries of Q and P will be computed,  and the other entries will be mirrored. Default is false.\nIf symmetricP is true, only the side with  non-positive P coordinate will be comptued, and the other entries will be mirrored. The default is to  be the same that symmetricQP.\nparallelize indicates whether to use all available workers. Defaults to true if this function is called  from worker 1, and false else.\nshow_progress turns the progress bar on/off. Default is true.\npbatch_size is the maximum number of batches to run in a single run in a single worker. The default value is automatically optimized depending on res and the number of workers.\nkargs... are redirected to ∫∫dqdpδϵ.\n\n\n\n\n\n","category":"function"},{"location":"EnergyShellProjections/#DickeModel.EnergyShellProjections.energy_shell_average","page":"EnergyShellProjections","title":"DickeModel.EnergyShellProjections.energy_shell_average","text":"function energy_shell_average(system::DickeSystem;\n    ϵ::Real,\n    f::Function,\n    res::Real=0.01,\n    symmetricQP::Bool=false,\n    symmetricP::Bool=symmetricQ)\n\nReturns the energy shell average\n\nfracj^2(2pi)^2nu(epsilon)int_mathcalMtextdmathbfx  delta(h_textcl(mathbfx)-epsilon) f(mathbfx)\n\nof f([Q,q,P,p]).\n\nArguments\n\nsystem should be an instance of ClassicalDicke.DickeSystem.\n\nKeyword arguments\n\nϵ is a real number\nf should be function with signature f([Q,q,P,p]) that returns values that may be added together (e.g. numbers, arrays, etc...).\nres determines the separation between the elements of Qs and Ps. It also determines p_res in the calls to ∫∫dqdpδϵ. It should be a positive real number that is an integer fraction of 2 (i.e. 2n for some n in mathbbN). Computation time is inversely proportional to the cube of this quantity.\nIf symmetricQP is true, only the non-positive entries of Q and P will be computed,  and the other entries will be mirrored. Default is false.\nIf symmetricP is true, only the side with  non-positive P coordinate will be comptued, and the other entries will be mirrored. The default is to  be the same that symmetricQP.\n\n\n\n\n\n","category":"function"},{"location":"EnergyShellProjections/#Integrals-of-Husimi-functions","page":"EnergyShellProjections","title":"Integrals of Husimi functions","text":"","category":"section"},{"location":"EnergyShellProjections/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"rényi_occupation_and_proj_husimi_QP_matrix\nrényi_occupation\nproj_husimi_QP_matrix","category":"page"},{"location":"EnergyShellProjections/#DickeModel.EnergyShellProjections.rényi_occupation_and_proj_husimi_QP_matrix","page":"EnergyShellProjections","title":"DickeModel.EnergyShellProjections.rényi_occupation_and_proj_husimi_QP_matrix","text":"function rényi_occupation_and_proj_husimi_QP_matrix(system::DickeBCE.QuantumDickeSystem,\n    states::AbstractVecOrMat{<:Number};\n    res::Real,\n    chop::Real=1e-4,\n    nonvalue=NaN,\n    mix_states::Bool=false,\n    mix_function::Function=mean,\n    α::Union{AbstractArray{<:Real,1},Real}=2,\n    matrix_powers::Union{AbstractArray{<:Real,1},Real}=1,\n    kargs...)\n\nReturns a tuple (Ls,(Qs,Ps,matrices)) where Ls contains the Rényi occupations given by Eq. (30) of Ref. [20], and matrices contains  the values of the projections\n\n    iint textd qtextd p delta(h_textcl(QqPp)-epsilon) mathcalQ_psi(QqPp)^alpha\n\nwhere mathcalQ_psi(mathbfx) = left  left langle mathbfx  middle  psi right rangle right ^2  is the Husimi function of state left  psi right rangle, for each Q in Qs and P in Ps. The values alpha in α (which may be a vector or a number) determine the order of the Rényi occupations, and matrix_powers determine the powers of the projections. \n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nstates may be a vector (single state) or a matrix of multiple states as columns.  The states are assummed to be in the efficient coherent basis. In the special case that the length of the states is 4, they are instead assumed to be the coordinates [Q,q,P,p] of a coherent state, and husimi_of_coherent is used. \n\nKeyword arguments\n\nϵ, Q, and P (which are epsilon, Q, and P above) have to be passed.\nchop is passed to DickeBCE.coherent_overlap.\nres determines the resolution of the integral, as in matrix_QP∫∫dqdpδϵ.\nnonvalue is the value to return if QP are outside of the energy shell at epsilon. Default is NaN.\nmix_states switches the behaviour if states is a matrix. If false (default), a result is returned for each state. If true, the Husimis are first passed to mix_function, and the result is integrated.  \nmix_function – when mix_states is true, this function is evaluated with the resulting Husimis mix_function([Qstate1,Qstate2, ...]) before manipulating them. Each number Qstatei corresponds to the Husimi function of the ith column of states.  The default function is mean, which is equivalent to treating the matrix states as a mixed state with equal weights. Custom weights could be used by passing mix_function([Qstate1,Qstate2, ...]) = p1*Qstate1 + p2*Qstate2 + .... Moreover, mix_function may return a vector: for example, mix_function([Qstate1,Qstate2, ...]) = [Qstate1, (Qstate1 + Qstate2)/2] would compute Ls and matrices for two states: first for state1, and second the mixed state composed of half state1 and half state2. This allows to compute several quantities in one run. Another example, mix_function(hus) = [hus; mean(hus)] will compute all the individual states, along with the equally-weighted mixed state.\nα may be a number or an array, determining the orders of the Rényi occupations Ls. Defaults to 2.\nmatrix_powers may be a number or an array, determining the orders of the moments in the projections matrices. matrix_powers  should be a subset of α ∪ {1}. Defaults to 1.\nkargs are redirected to matrix_QP∫∫dqdpδϵ\n\n\n\n\n\n","category":"function"},{"location":"EnergyShellProjections/#DickeModel.EnergyShellProjections.rényi_occupation","page":"EnergyShellProjections","title":"DickeModel.EnergyShellProjections.rényi_occupation","text":"function rényi_occupation\n\nReturns only the Rényi occupations Ls in rényi_occupation_and_proj_husimi_QP_matrix, same arguments apply, although matrix_powers is ignored.\n\n\n\n\n\n","category":"function"},{"location":"EnergyShellProjections/#DickeModel.EnergyShellProjections.proj_husimi_QP_matrix","page":"EnergyShellProjections","title":"DickeModel.EnergyShellProjections.proj_husimi_QP_matrix","text":"function proj_husimi_QP_matrix\n\nReturns only the projection matrices (Qs,Ps,matrices) in rényi_occupation_and_proj_husimi_QP_matrix, same arguments apply, although α should not be passed.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCEExamples/#Examples-for-DickeBCE","page":"DickeBCE (Quantum Dicke)","title":"Examples for DickeBCE","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\ncache_fold_name=\"./diags\"\nuse_current_dir_for_diags=on_github\nusing DickeModel","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"The module DickeModel.DickeBCE works with the quantum Dicke model using a very efficient basis known as the coherent efficient basis (BCE for its acronym in Spanish). See Refs. [4] and [5] for a detailed explanation on how and why it works.  Throughout this examples, we will work with a system size of j = 30, but  using this module you can easily go up to j = 100 (as done in Refs. [13], [14], [15], [20]) and beyond.","category":"page"},{"location":"DickeBCEExamples/#Diagonalizing-the-Dicke-Hamiltonian","page":"DickeBCE (Quantum Dicke)","title":"Diagonalizing the Dicke Hamiltonian","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"Let us start by defining our parameters:","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"@info \"Starting example: Diagonalization\"","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"using DickeModel.DickeBCE, DickeModel.ClassicalDicke\nsystem = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j=30, Nmax=120)\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"To load the eigenbasis, simply use diagonalization:","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"if !use_current_dir_for_diags #hide\n@time eigenenergies,eigenstates = diagonalization(system)\nelse #hide\n@time eigenenergies,eigenstates = diagonalization(system, cache_folder=cache_fold_name, load_cache=false)  #hide\nend #hide\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"Diagonalizing the Hamiltonian is an expensive operation. For j = 100 and Nmax = 300 it can take up to a day, but the function diagonalization saves the result to disk, so the second time you call it with the same parameters it just loads it:","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"system = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j = 30) \nif on_github && use_current_dir_for_diags #hide\neigenenergies,eigenstates =  diagonalization(system, cache_folder=cache_fold_name,verbose=false) #hide\nend #hide\nif !use_current_dir_for_diags #hide\n@time eigenenergies,eigenstates =  diagonalization(system)\nelse #hide\n@time eigenenergies,eigenstates =  diagonalization(system,cache_folder=cache_fold_name) #hide\nend #hide\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"Note that we did not have to pass Nmax this time, it loaded it from disk  (see more details on the documentation of QuantumDickeSystem). ","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"You can change the default folder, or disable caching altogether by passing extra arguments to diagonalization.","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"The resulting eigenstates form a matrix. To get the kth eigenstate, simply call state_k = eigenstates[:,k] (or, even better, state_k = @view eigenstates[:,k], which avoids unnecessary memory allocations.)","category":"page"},{"location":"DickeBCEExamples/#quantumldoscoherentstateex","page":"DickeBCE (Quantum Dicke)","title":"Local density of states of a coherent state","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"In this example, we obtain the eigenenergy components of a coherent state. The function coherent_state will give us a coherent state in the BCE, then we project it into the eigenbasis by left-multiplying by eigenstates', which is short for  adjoint(eigenstates). Finally, we broadcast the vectorized version of the function abs2 to extract all the coefficients.","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"@info \"Starting example: Coherent LDoS\"","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"using Plots\nusing DickeModel.DickeBCE, DickeModel.ClassicalDicke\nj = 30\nsystem = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j = j, Nmax=120)\nif false #hide\neigenenergies,eigenstates = diagonalization(system) \nend #hide\n\nϵₓ = -0.5\nx = Point(system, Q=-1, P=0, p=0, ϵ=ϵₓ)\ncoh_state = coherent_state(system, x)\ncoherent_state_eigenbasis = eigenstates'*coh_state \nabscₖ²=abs2.(coherent_state_eigenbasis)\nϵₖs = eigenenergies/j\n\n   \nplot(histogram(ϵₖs, weights=abscₖ²,\n        ylabel=\"Probability density\", xticks=:none,normed=true,nbins=50),\n    \n    scatter(ϵₖs, abscₖ², ylabel=\"|cₖ|²\", xlabel=\"ϵ\"),\n    \n   size=(700,500), key=false, layout=(@layout [°;°]),\n   xlim=(ϵₖs[1],ϵₖs[end]))\nsavefig(\"LDoS_quantum.svg\");nothing #hide","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"(Image: )","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"See this example for a semiclassical computation of the envelope of this function.","category":"page"},{"location":"DickeBCEExamples/#ExampleEfficientHusimiFunctions","page":"DickeBCE (Quantum Dicke)","title":"Efficient Husimi functions","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"The functions DickeBCE.husimi,  DickeBCE.coherent_overlap, and DickeBCE.coherent_state all accept a chop argument, which allows to significally speed up computation time at the cost of slight numerical precision [11]. In this example we show how significant this speedup can be. Let us construct a big system:","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"@info \"Starting example: Efficient Husimi\"","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"using DickeModel\nusing DickeModel.DickeBCE\nusing DickeModel.ClassicalDicke\nusing LinearAlgebra\n\nj = 600\nNmax = 1200\nsystem = QuantumDickeSystem(ω₀=1, ω=1, γ=1, j=j, Nmax=Nmax);\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"Do not try to diagonalize such a big system! Your computer 💻 might explode 💥!","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"For the sake of example, let us construct some random states in a simple manner (although if you are interested in building random states in the eigenbasis, check the function DickeBCE.random_state and see this example).","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"n = 3 #how many random vectors\nD = dimension(system)\nrandom_vectors = rand(ComplexF64,(D,n))\nfor i in 1:n\n    random_vectors[:,i] /= norm(@view random_vectors[:,i]) #normalize each one\nend \nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"random_vectors is a matrix with n columns (states). Let us fix a point in the phase space:","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"x = Point(Q=0.6, P=-0.1, p=-0.2, q=-0.8)\nhusimi(system,x,random_vectors) #hide\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"We may call husimi(system, x, random_vectors), which will return an array with n elements. The ith element is the result of evaluating the Husimi function  of the ith state (column) at the point x.","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"@time husimi(system, x, random_vectors, chop = 0)","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"By passing chop = 0 we are allowing for no optimization. The code has to build all the coefficients of the coherent state and then multiply them by each coefficient in random_vectors. However, if we set chop to be slightly bigger, things will speed up significantly:","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"@time husimi(system, x, random_vectors, chop = 1e-14)","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"Note that the results barely changed, but this time it used a lot less memory and time. The chop argument tells the code it can chop a portion of that size off the  tails of the distribution of the coherent state (see Ref. [11] for details).  You loose almost no information, and you gain a lot of time. The default is chop = 1e-6, although you may increase it if you need more precision:","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"@time husimi(system, x, random_vectors) #default chop = 1e-6","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"That's fast!","category":"page"},{"location":"DickeBCEExamples/#wignerfuncexample","page":"DickeBCE (Quantum Dicke)","title":"Projected Wigner function of a cat state","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"Using DickeBCE.WignerProjqp, we may compute the Wigner function of a state, projected onto the atomic plane. We do this for a cat state composed of two coherent states centered at x and y, which, taking advantage of Julia's Unicode capabilities, we name 🐱 (write \\:cat: + Tab).","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"@info \"Starting example: Wigner Cat\"","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"using DickeModel.ClassicalDicke, DickeModel.DickeBCE\nsystem = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j=10, Nmax=50) \nres=0.025\nif !on_github res=0.2 end #hide\nQs=Ps=-2:res:2\npts=[[Q,P] for Q in Qs, P in Ps if Q^2+P^2 <= 4]\n\nx = Point(Q=-1.0, P=0, p=0, q=0)\ny = Point(Q= 1.0, P=0, p=0, q=0)\n🐱 = 1/sqrt(2) * (coherent_state(system, x) + coherent_state(system, y))\n\nW=DickeBCE.WignerProjqp(system, \n                    [🐱], \n                    pts\n                    ,show_progress = false, #hide\n                    )[1]\nd=Dict(zip(pts,W))\nfunction mW(Q,P)\n    if [Q,P] in pts\n        return d[[Q,P]]\n    else\n        return NaN\n    end\nend\nheatmap(Qs, Ps, mW, size=(600,600),\n    xlabel = \"Q\", ylabel = \"P\",\n    c=cgrad(:bwr, rev = true), clim=(-2.5,2.5))\nsavefig(\"catWigner.svg\");nothing #hide","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"(Image: )","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"note: Note\nThe functions for computing Wigner functions are not thoroughly tested nor thoroughly optimized. They are based on these notes [10], but they have room for improvement.","category":"page"},{"location":"DickeBCEExamples/#Plotting-the-semiclassical-density-of-states","page":"DickeBCE (Quantum Dicke)","title":"Plotting the semiclassical density of states","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"Using DickeBCE.density_of_states, we plot the semiclassical  density of states originally calculated in Ref. [3]. Note that this function does not require diagonalization, so we can have j as large as we want.","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"@info \"Starting example: DoS\"","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"using DickeModel.ClassicalDicke\nusing DickeModel.DickeBCE\n\nusing Plots\nsystem = QuantumDickeSystem(ω=1, γ=1, ω₀=1, j=100)\n\nν(ϵ) = density_of_states(system, ϵ)\nϵgs = minimum_energy(system)\nplot(ν, ϵgs:0.01:2, xlabel=\"ϵ\", ylabel=\"Density of States\")\nplot!(key=false) #hide\nsavefig(\"density_of_states.svg\"); nothing #hide","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"(Image: )","category":"page"},{"location":"DickeBCEExamples/","page":"DickeBCE (Quantum Dicke)","title":"DickeBCE (Quantum Dicke)","text":"This is precisely the red line in Fig. A1. of Ref. [19].","category":"page"},{"location":"ClassicalLMGExamples/#Examples-for-ClassicalLMG","page":"ClassicalLMG","title":"Examples for ClassicalLMG","text":"","category":"section"},{"location":"ClassicalLMGExamples/","page":"ClassicalLMG","title":"ClassicalLMG","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\nusing DickeModel","category":"page"},{"location":"ClassicalLMGExamples/#Exponential-growth-of-the-FOTOC-using-the-TWA","page":"ClassicalLMG","title":"Exponential growth of the FOTOC using the TWA","text":"","category":"section"},{"location":"ClassicalLMGExamples/","page":"ClassicalLMG","title":"ClassicalLMG","text":"In Ref. [12], it was shown that the fidelity out-of-time order  correlator (FOTOC) corresponding the the unstable fixed point (QP)=(00) at the excited-state  quantum phase transition of the Lipkin-Meshkov-Glick (LMG) model grows eponentially,  even though it is a regular system. In this example we calculate such quantity  using the Truncated Wigner Approximation (TWA)","category":"page"},{"location":"ClassicalLMGExamples/","page":"ClassicalLMG","title":"ClassicalLMG","text":"@info \"Starting example: LMG FOTOC\"","category":"page"},{"location":"ClassicalLMGExamples/","page":"ClassicalLMG","title":"ClassicalLMG","text":"using DickeModel.TWA, DickeModel.ClassicalLMG\nusing Plots\n\nfixed_point = ClassicalLMG.Point(Q=0, P=0)\n\nsystemLMG = ClassicalLMGSystem(Ω=1, ξ=-1)\nj = 500\nW = coherent_Wigner_SU2(fixed_point, j =j)\nts=0:0.1:50\nif !on_github #hide\n  ts=0:10 #hide\nend #hide\nFOTOC= sum.(\n        variance(systemLMG,\n            observable = [:Q,:P], \n            N = 5000, \n            ts = ts, \n            show_progress = false, #hide\n            distribution = W)\n    )\n\nplot(ts,FOTOC,\n    yscale=:log10,\n    xlabel=\"time\",\n    ylabel=\"FOTOC\",\n    key=false)\nsavefig(\"FOTOCLMG.svg\"); nothing #hide","category":"page"},{"location":"ClassicalLMGExamples/","page":"ClassicalLMG","title":"ClassicalLMG","text":"(Image: )","category":"page"},{"location":"ClassicalLMG/#DickeModel.ClassicalLMG","page":"ClassicalLMG","title":"DickeModel.ClassicalLMG","text":"","category":"section"},{"location":"ClassicalLMG/","page":"ClassicalLMG","title":"ClassicalLMG","text":"For examples of usage, go to  Examples for ClassicalLMG.","category":"page"},{"location":"ClassicalLMG/","page":"ClassicalLMG","title":"ClassicalLMG","text":"CurrentModule = DickeModel.ClassicalLMG","category":"page"},{"location":"ClassicalLMG/","page":"ClassicalLMG","title":"ClassicalLMG","text":"ClassicalLMGSystem\nhamiltonian","category":"page"},{"location":"ClassicalLMG/#DickeModel.ClassicalLMG.ClassicalLMGSystem","page":"ClassicalLMG","title":"DickeModel.ClassicalLMG.ClassicalLMGSystem","text":"struct ClassicalLMGSystem <: ClassicalSystems.ClassicalSystem\n\nSubtype of ClassicalSystems.ClassicalSystem which represents the classical LMG model with the given parameters Ω and ξ. See Eq. (2) of Ref. [12]. To generate this struct, use the constructor\n\n    ClassicalLMGSystem(;Ω::Real,ξ::Real)\n\nFor example, system = ClassicalLMGSystem(Ω=1, ξ=1).\n\nThis struct may be passed to all functions in this module that require an instance of ClassicalLMG.ClassicalLMGSystem, as well as functions in other modules that require the abstract ClassicalSystems.ClassicalSystem,  such as  ClassicalSystems.integrate.\n\n\n\n\n\n","category":"type"},{"location":"ClassicalLMG/#DickeModel.ClassicalLMG.hamiltonian","page":"ClassicalLMG","title":"DickeModel.ClassicalLMG.hamiltonian","text":"function hamiltonian(system::ClassicalLMGSystem)\n\nReturns a classical Hamiltonian function h(x) where x=[Q,P], which is given by Eq. (2) of Ref. [12].\n\nArguments\n\nsystem should be generated with ClassicalLMG.ClassicalLMGSystem.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalLMG/#Phase-space","page":"ClassicalLMG","title":"Phase space","text":"","category":"section"},{"location":"ClassicalLMG/","page":"ClassicalLMG","title":"ClassicalLMG","text":"Point\nPointθϕ","category":"page"},{"location":"ClassicalLMG/#DickeModel.ClassicalLMG.Point","page":"ClassicalLMG","title":"DickeModel.ClassicalLMG.Point","text":"function Point(;Q::Real,P::Real)\n\nReturns the list [Q,P]\n\n\n\n\n\nfunction Point(system::ClassicalLMGSystem;\n    Q::Real,\n    ϵ::Real,\n    sgn::Union{typeof(-),typeof(+)} = +)\n\nReturns a list [Q,P], where P is calculated with P_of_ϵ.  If there are no solutions for P, an error is raised.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalLMG/#DickeModel.ClassicalLMG.Pointθϕ","page":"ClassicalLMG","title":"DickeModel.ClassicalLMG.Pointθϕ","text":"function Pointθϕ(;θ::Real,ϕ::Real)\n\nReturns a list [Q,P], where Q and P are calculated from θ and ϕ using PhaseSpaces.Q_of_θϕ and  PhaseSpaces.P_of_θϕ.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalLMG/#Roots-in-P","page":"ClassicalLMG","title":"Roots in P","text":"","category":"section"},{"location":"ClassicalLMG/","page":"ClassicalLMG","title":"ClassicalLMG","text":"discriminant_of_P_solution\nP_of_ϵ\nPoint(::ClassicalLMGSystem)","category":"page"},{"location":"ClassicalLMG/#DickeModel.ClassicalLMG.discriminant_of_P_solution","page":"ClassicalLMG","title":"DickeModel.ClassicalLMG.discriminant_of_P_solution","text":"function discriminant_of_P_solution(system::ClassicalLMGSystem,Q::Real,ϵ::Real)\n\nReturns the discriminant of the second degree equation in P given by\n\n    h_textcl(QP)=epsilon\n\nwhere h_textcl is given by Eq. (2) of Ref. [12].\n\nArguments\n\nsystem should be generated with ClassicalLMGSystem.\nQ and ϵ are the values of Q and epsilon, respectively.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalLMG/#DickeModel.ClassicalLMG.P_of_ϵ","page":"ClassicalLMG","title":"DickeModel.ClassicalLMG.P_of_ϵ","text":"function P_of_ϵ(system::ClassicalLMGSystem;\n    Q::Real,\n    ϵ::Real,\n    sgn::Union{typeof(-),typeof(+)}=+,\n    returnNaNonError::Bool=true)\n\nReturns the solutions P_pm of the second degree equation in P given by\n\n    h_textcl(QP)=epsilon\n\nwhere h_textcl is given by Eq. (2) of Ref. [12].\n\nArguments\n\nsystem should be generated with ClassicalLMGSystem.\n\nKeyword arguments\n\nQ and ϵ are values of Q and epsilon, respectively.\nsgn is + for P_+ and - for P_-\nIf returnNaNonError is true, then NaN is returned if there are no solutions. If it is false, and error is raised.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalLMG/#DickeModel.ClassicalLMG.Point-Tuple{DickeModel.ClassicalLMG.ClassicalLMGSystem}","page":"ClassicalLMG","title":"DickeModel.ClassicalLMG.Point","text":"function Point(system::ClassicalLMGSystem;\n    Q::Real,\n    ϵ::Real,\n    sgn::Union{typeof(-),typeof(+)} = +)\n\nReturns a list [Q,P], where P is calculated with P_of_ϵ.  If there are no solutions for P, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalLMG/#Energy-minimizing","page":"ClassicalLMG","title":"Energy minimizing","text":"","category":"section"},{"location":"ClassicalLMG/","page":"ClassicalLMG","title":"ClassicalLMG","text":"minimum_ϵ_for","category":"page"},{"location":"ClassicalLMG/#DickeModel.ClassicalLMG.minimum_ϵ_for","page":"ClassicalLMG","title":"DickeModel.ClassicalLMG.minimum_ϵ_for","text":"function minimum_ϵ_for(system::ClassicalLMGSystem;\n    Q::Union{Real,Nothing}=nothing,\n    P::Union{Real,Nothing}=nothing)\n\nReturns the minimum energy epsilon when constraining the system to  one fixed value of the coordinates Q or P.\n\nArguments\n\nsystem should be generated with ClassicalLMGSystem.\n\nKeyword arguments\n\nYou may pass either P or Q.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDickeExamples/#Examples-for-ClassicalDicke","page":"ClassicalDicke","title":"Examples for ClassicalDicke","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\nusing DickeModel","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"The module DickeModel.ClassicalDicke works with the classical Dicke model, which is obtained by taking the expectation value of the quantum dicke model under coherent states (see, for example, Ref. [19]). The classical Dicke Hamiltonian is, regular at low energies, and chaotic at high energies. (see, for example, Ref. [12]). ","category":"page"},{"location":"ClassicalDickeExamples/#Drawing-contours-of-the-available-phase-space","page":"ClassicalDicke","title":"Drawing contours of the available phase space","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"We may use the function ClassicalDicke.minimum_ϵ_for to draw the contour of the available phase space in the variables (QP).","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"@info \"Starting example: Countours\"","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"using DickeModel.ClassicalDicke\nusing Plots\nsystem =  ClassicalDickeSystem(ω=1, γ=1, ω₀=1)\nQs = Ps = -2:0.01:2\nϵgs = minimum_energy(system)\ncontour(Qs, Ps,\n        (Q,P) -> minimum_ϵ_for(system, p=0, P=P, Q=Q),\n        levels=10, clim=(ϵgs,1), xlabel=\"Q\", ylabel=\"P\")\nsavefig(\"contourQP.svg\"); nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/#Animating-the-classical-evolution","page":"ClassicalDicke","title":"Animating the classical evolution","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"We may use ClassicalSystems.integrate to classically evolve a point in  the phase space. In this example, we compute the evolution of a point in the chaotic regime of the phase space, and project it into the bosonic (qp) plane. We use @animate from Plots to create an animation.","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"@info \"Starting example: Point animation\"","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"using DickeModel, DickeModel.ClassicalDicke, DickeModel.ClassicalSystems\nusing Plots\nsystem = ClassicalDickeSystem(ω=1, ω₀=1, γ=1)\nϵ = -0.5\nu0 = Point(system, Q=0, P=0, p=0, ϵ = ϵ)\ntimes = 0:200\nif !on_github #hide\n    times = 0:10 #hide\nend #hide\n\nu = integrate(system, u0, times[end]) \n\n# plot of border (see previous example)\npl=contour(-4:0.01:4, -2:0.01:2,\n        (q,p) -> minimum_ϵ_for(system; P=0,p,q),\n        levels=[ϵ], xlabel=\"q\", \n        ylabel=\"p\", color=:black, key=false)\n\nanimation = @animate for t in times\n    plot(pl, u, tspan=(0,t), vars=(:q,:p), xlim=(-4,4))\nend\nmp4(animation,\n    show_msg=false, #hide\n    \"animation_of_classical_evolution.mp4\")\nnothing; #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/#Drawing-a-Poincaré-surface","page":"ClassicalDicke","title":"Drawing a Poincaré surface","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"Using ClassicalSystems.integrate,  we may evolve initial conditions under the classical Dicke Hamiltonian. In this example we draw a Poincaré surface for the mixed regime Dicke model, where chaos and regularity coexist. We to integrate a bunch of initial conditions, and, using the callback system of DifferentialEquations, we save the points where p=0.","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"@info \"Starting example: Poincare\"","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"using DickeModel, DickeModel.ClassicalDicke, DickeModel.ClassicalSystems\nusing Plots\nusing DiffEqBase\n\nsystem=ClassicalDickeSystem(ω=0.8, γ=0.8, ω₀=1)\nmplot=scatter(fmt=:png, key=false, markersize=1, legend=false,\n    size=(500,500), color_palette=:darkrainbow, xlabel=\"Q\", ylabel=\"P\") \n\npts = Tuple{Float64, Float64}[] #a list of points (Q,P)\nfunction save(state) #this function saves (Q,P) to pts if q = q₊ (and not q₋).\n    if q_sign(system,state.u,ϵ) == + \n        Q,q,P,p = state.u \n        push!(pts, (Q,P))  \n    end                     \nend\ncallback=ContinuousCallback((x, t, _) -> x[4], #when p=x[4] is 0,\n    save; #execute the function save\n    save_positions=(false,false), abstol=1e-3)\nϵ = -1.35\n\n# We evolve a bunch of initial conditions with different Q values:\nfor Q in minimum_nonnegative_Q_for_ϵ(system,ϵ):0.02:maximum_Q_for_ϵ(system, ϵ) \n        if minimum_ϵ_for(system, P=0, p=0, Q=Q) > ϵ\n            continue\n        end\n        initial_condition = Point(system, ϵ=ϵ, P=0, p=0, Q=Q)\n        integrate(system, initial_condition, 10000,\n             callback=callback, save_everystep=false)\n        scatter!(pts)\n        empty!(pts)\n        if !on_github break end #hide\nend\nmplot\nsavefig(\"poincare_surface.png\");nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/#Drawing-a-Lyapunov-exponent-map","page":"ClassicalDicke","title":"Drawing a Lyapunov exponent map","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"Let us plot the Lyapunov exponents for the Poincaré map of the previous example. The code below is lengthy, but here's the idea in a nutshell:","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"Computing Lyapunov exponents is expensive, because one needs to integrate the variational system to obtain the fundamental matrix in the tangent space. However, any two points in the same trajectory will share the same Lyapunov exponent,  so we may compute the Lyapunov exponent for an initial condition, and all other points that it passes through have the same one.","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"This code below generates a matrix in the plane (p = 0epsilon = textconstant),  and averages the Lyapunov exponent of all the trajectories that pass through each square in the matrix. It starts taking initial conditions for the matrix, but if it reaches a square which another trajectory has crossed, it skips it, because it already knows the corresponding Lyapunov exponent.","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"@info \"Starting example: Lyapunov map\"","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"using DickeModel, DickeModel.ClassicalDicke, DickeModel.ClassicalSystems\nusing Plots\nusing DiffEqBase\n\nsystem = ClassicalDickeSystem(ω=0.8, γ=0.8, ω₀=1)\nϵ = -1.35\nn_points = 50 #making this greater will make a smoother plot,\n              #but it may take time!\nif !on_github n_points = 5 end #hide\n\n#we calculate the bounds\nmaxQ = maximum_Q_for_ϵ(system,ϵ)\nminQ = minimum_nonnegative_Q_for_ϵ(system,ϵ) \nmaxP = maximum_P_for_ϵ(system,ϵ) \n\nQs = range(minQ, maxQ, length = n_points)\nPs = range(0, maxP, length = n_points)  #we only compute the top half of \n                          #the plane, and later mirror it\n\n#this matrix will contain the average Lyapunov exponents of the n trajectories \n#that have passed through that square  or NaN if the point is outside of the\n#available phase space.\nmat_av_lya = [\n        if minimum_ϵ_for(system, P=P, p=0, Q=Q) > ϵ \n            NaN \n        else \n            0.0 \n        end \n    for Q in Qs, P in Ps\n    ]\n                \n#this matrix will contain the count of how many trajectories \n#have passed through that square.\nmat_counts =zeros(Int,length(Qs),length(Ps))\n#a list of points (Q,P) to temporarily store the points through \n# which a given trajectory passes through. \npts = Tuple{Float64, Float64}[] \n\n#this function saves (Q,P) to pts if q = q₊ (and not q₋).\nfunction save(state) \n    if ClassicalDicke.q_sign(system,state.u,ϵ) == + \n        Q,q,P,p = state.u \n        push!(pts, (Q,P))  \n    end                     \nend\ncallback = ContinuousCallback((x, t, _) -> x[4], #when p=x[4] is 0,\n            save; #execute the function save\n            save_positions=(false,false), abstol=1e-3)\n            \n#an auxiliary function, which gives the index k so that r[k] ≥ v >r[k]\nfunction index_of_subinterval(v,r) \n    if r[end] <v\n        return length(r)\n    end\n    if v < r[1] \n        return 1\n    end\n    return Int(round(((v-r[1])/(r[end]-r[1]))*(length(r)-1) +1))\nend\n\n#we iterate over the matrix and the values of Q,P\nfor ((Q,P),av_lyapunov,count) in zip(Iterators.product(Qs,Ps),mat_av_lya,mat_counts)\n    # if we are out of the available phase space or we \n    # already have one trajectory that has passed through this square\n    if av_lyapunov===NaN || count > 0 \n        continue #we skip\n    end\n\n    #the following 4 lines will populate pts with all the points (mQ,mP) in the \n    #Poincaré map that the trajectory starting at (Q,P) passes through.\n    empty!(pts)\n    push!(pts,(Q,P))\n    point  = ClassicalDicke.Point(system, Q=Q, P=P, p=0, ϵ=ϵ)\n    λ = ClassicalSystems.lyapunov_exponent(system, point,\n        verbose = false, #hide\n        #decreasing these numbers will produce more precise results but takes more time. \n        tol = 1e-8,\n        λtol = 0.00005,  \n        callback = callback)\n\n    for (mQ,mP) in pts\n        #we save the Lyapunov into all of the squares that the trajectory visited.\n        iQ,iP = index_of_subinterval(mQ,Qs),index_of_subinterval(abs(mP),Ps)\n        #if we are inside the available phase space\n        if mat_av_lya[iQ,iP] !== NaN\n            #we update the average\n            mat_av_lya[iQ,iP] = (mat_av_lya[iQ,iP]*mat_counts[iQ,iP] + λ) /\n                                (mat_counts[iQ,iP] + 1)  \n            mat_counts[iQ,iP] += 1 #we update the count\n        end\n    end\nend\n\nmat=transpose(mat_av_lya) #we transpose because heatmap takes transposed matrices.\nmat=vcat(mat[end:-1:2,1:end], mat) #mirror in P\nPs=vcat(-Ps[end:-1:2], Ps) #update Ps with negative values\n\nheatmap(Qs, Ps, mat, \n        xlabel=\"Q\", ylabel=\"P\", \n        clim=(0.01,NaN), #Lyapunovs below 0.005 we take as 0\n        size=(550,500))\nsavefig(\"lyapunov_map.svg\");nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/","page":"ClassicalDicke","title":"ClassicalDicke","text":"It looks very similar to the Poincaré map of the previous example! Notice how there are regular (black) and chaotic (colored) regions.","category":"page"},{"location":"EnergyShellProjectionsExamples/#Examples-for-EnergyShellProjections","page":"EnergyShellProjections","title":"Examples for EnergyShellProjections","text":"","category":"section"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\ncache_fold_name=\"./diags\"\nuse_current_dir_for_diags=on_github\nusing DickeModel","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"The module DickeModel.EnergyShellProjections allows to integrate functions in the classical energy shells of the Dicke model, and has specialized functions for projections of the Husimi function and its moments.","category":"page"},{"location":"EnergyShellProjectionsExamples/#Projections-of-eigenstates","page":"EnergyShellProjections","title":"Projections of eigenstates","text":"","category":"section"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"Let us first consider the projection","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"    iint textd qtextd p delta(h_textcl(QqPp)-epsilon_k) mathcalQ_k(QqPp)","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"of the Husimi function mathcalQ_k(mathbfx) = left  left langle mathbfx middle  E_k right rangle right ^2 of an eigenstate left  E_k right rangle into the atomic plane intersected with the energy shell at epsilon_k=E_kj (see Ref. [14]). We will use the function EnergyShellProjections.proj_husimi_QP_matrix to compute such quantity. This function is optimized to parallelize using multiple workers if available, so let us load some as well. This is done using Distributed.","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"using DickeModel\nusing DickeModel.DickeBCE\nusing DickeModel.ClassicalDicke\nusing DickeModel.EnergyShellProjections\nusing Distributed\nusing Plots\nj = 30\nNmax = 120\nsystem = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j=j, Nmax=Nmax)\nif false #hide\neigenenergies,eigenstates = diagonalization(system) \nend #hide\nif !use_current_dir_for_diags #hide\neigenenergies,eigenstates =  diagonalization(system,verbose=false) #hide\nelse #hide\neigenenergies,eigenstates =  diagonalization(system, cache_folder=cache_fold_name,verbose=false)  #hide\nend #hide\nϵs=eigenenergies/j\nif false #hide\naddprocs(2) #we add 2 workers. Add as many as there are cores in your computer.\n@everywhere using DickeModel\nend #hide\nnothing; #hide","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"The function proj_husimi_QP_matrix will make use of all the available workers (you may disable this by passing parallelize = false)","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"note: Note\nThe line @everywhere using DickeModelis necessary to load the module DickeModel in all workers. You will get errors if you omit it.","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"We compute the projection for the eigenstate with k = 600.","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"@info \"Starting example: Eigenstate Projection\"","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"k = 600\nstate = eigenstates[:,k]  \nϵₖ = ϵs[k]\nres = 0.02\nif !on_github #hide\n    res = 0.5 #hide\nend #hide\nheatmap(\n    EnergyShellProjections.proj_husimi_QP_matrix(system,\n        state,\n        ϵ = ϵₖ,\n        symmetricQP = true,\n        show_progress = false,#hide\n        chop = 1e-2, # Here 1e-2 is enough, but see what works for you\n        res = res)...,\n    xlabel = \"Q\",\n    ylabel = \"P\")\nsavefig(\"k600stateprojhu.svg\");nothing #hide","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"(Image: )","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"tip: Tip\nNote that we set chop = 1e-2 above, which decreases computation time and practically does not affect the result. If you decrease chop in this example, computation time  will increase but the plot will look the same. Always try to increase chop as much as your tolerance for numerical errors allows.  See this example for details on chop.","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"Using the function proj_husimi_QP_matrix  we can also plot the projection of the alpha-moments of the Husimi function, which are given by","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"    iint textd qtextd p delta(h_textcl(mathbfx)-epsilon_k) mathcalQ_k(mathbfx)^alpha","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"for  alphageq 0. Let us do this for k = 750 and four values of alpha, [0.5,1,2,3,4], which are passed to the keyword argument matrix_powers.","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"@info \"Starting example: Husimi powers\"","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"k = 750\nstate = eigenstates[:,k]  \nϵₖ = ϵs[k]\npowers = [0.5,1,2,3,4] \nres = 0.04\nif !on_github #hide\n    res = 0.5 #hide\nend #hide\nQs,Ps,matrices=EnergyShellProjections.proj_husimi_QP_matrix(system,\n    state,\n    ϵ = ϵₖ,\n    show_progress = false, #hide\n    matrix_powers = powers,\n    symmetricQP = true,\n    chop = 1e-2,\n    res = res)\n\nplot(\n    [heatmap(Qs,Ps,mat,\n            key = false,\n            xlabel = \"Q\",\n            ylabel = if α==powers[1] \"P\" else \"\" end,\n            yticks =  α==powers[1],\n                left_margins = if α==powers[1] 20Plots.px else -5Plots.px end,\n            right_margins= -5Plots.px,\n            bottom_margins= 20Plots.px,\n            clim = (0,NaN),\n            title = \"α = $α\",\n            \n        ) \n        for (α,mat) in zip(powers,matrices)\n    ]...,\n    layout=(1,length(powers)),\n    size=(1000,200),\n    titlefontsize=10,\n    tickfontsize=6,\n)\nsavefig(\"k700momentsstateprojhu.svg\");nothing #hide","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"(Image: )","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"The function proj_husimi_QP_matrix  can also receive multiple states as columns in a matrix. Even more, if these states  are just vectors of length 4 [Q,q,P,p], the function assumes you want the coherent  state centered at [Q,q,P,p]. There is an analytical formula for the Husimi function  of a coherent state (See husimi_of_coherent),  so the coefficients of the coherent state are not even calculated, and the result is much faster:","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"@info \"Starting example: Coherent Heart\"","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"ts = range(-π+0.3, -0.4, length = 30) ∪ range(0.2, π-0.6, length = 20)\n💗(t) = (1.5sin(t)^3,(13cos(t) - 5cos(2t) -2cos(3t) - cos(4t))/10)\nϵ = 1\nres = 0.04\nif !on_github #hide\n    res = 0.5 #hide\nend #hide\ncoherents = hcat([Point(system,Q=Q,P=P,p=0,ϵ=ϵ) for (Q,P) in 💗.(ts)]...)\nheatmap(EnergyShellProjections.proj_husimi_QP_matrix(system,coherents;\n    mix_states = true,\n    ϵ = ϵ,\n    show_progress = false, #hide\n    res = res),\n    size = (600,600),\n    color= :RdPu_9)\nsavefig(\"heartofcoherents.svg\");nothing #hide","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"(Image: )","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"Nota that above, we passed mix_states = true to proj_husimi_QP_matrix. This tells the code to average together all of the Husimi functions of the states (using Statistics.mean), that is, you compute the Husimi function of the mixed state. You may even pass a  more complicated mix_function to add weights (see the documentation of rényi_occupation_and_proj_husimi_QP_matrix for details). If we had set mix_states = false (default), we would have obtained a matrix for each state. ","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"The fact that proj_husimi_QP_matrix may return the projection of multiple  states at the same time allows to create really nice animations. We evolve the state using DickeBCE.evolve.","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"@info \"Starting example: Husimi animation\"","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"ϵ = -0.5\nx = Point(system, Q=1, P=1, p=0, ϵ=ϵ)\ncoherent_x = coherent_state(system,x)\nts = 0:0.1:20\nres = 0.1\nif !on_github #hide\n    ts = 0:2 #hide\n    res= 0.5 #hide\nend #hide\nevolution = evolve(ts,coherent_x,eigenstates=eigenstates,eigenenergies=eigenenergies)\nQs,Ps,matrices=EnergyShellProjections.proj_husimi_QP_matrix(system,\n    evolution,\n    ϵ = ϵ,\n    show_progress = false, #hide\n    res = res,\n    chop = 1e-2)\n\nanimation=@animate for mat in matrices\n   heatmap(Qs, Ps, mat,\n        color = cgrad(:gist_heat, rev=true), size=(600,600),\n        xlabel=\"Q\", ylabel=\"P\", key=false)\nend\n\nmp4(animation,\n    \"animation_of_evolution_Husimi.mp4\",\n    show_msg=false, #hide\n    fps=15)\nnothing; #hide","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"(Image: )","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"tip: Tip\nIf you want better resolution, you may decrease res above. Computation time grows as the inverse cube of res. For example, doubling the resolution will increase the computation time eightfold.","category":"page"},{"location":"EnergyShellProjectionsExamples/#ExampleRenyiOccupationsRandomStates","page":"EnergyShellProjections","title":"Rényi occupations of random states","text":"","category":"section"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"In this example, we construct a set of random states from the Gaussian Orthogonal Ensemble (GOE) of Random Matrix Theory in the positive parity sector of the Dicke model  using the function DickeBCE.random_state. Then we study average Rényi Occupation (see Refs. [15] and [20]) using  EnergyShellProjections.rényi_occupation.","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"@info \"Starting example: Renyi occupation of random\"","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"using DickeModel\nusing DickeModel.DickeBCE\nusing DickeModel.ClassicalDicke\nusing DickeModel.EnergyShellProjections\nusing LinearAlgebra\nusing Statistics\nusing Plots\nj = 30\nNmax = 120\nsystem = QuantumDickeSystem(ω₀=1, ω=1, γ=1, j=j, Nmax=Nmax)\nif false #hide\neigenenergies,eigenstates =  diagonalization(system)\nend #hide\n\nϵ = -0.5\nn_of_states = 20\nif !on_github #hide\n    n_of_states = 2\nend #hide\nr_states = random_state(system, n_of_states,\n    eigenenergies = eigenenergies,\n    eigenstates = eigenstates,\n    ϵ = ϵ, #center of gaussian envelope\n    σ = 0.5,  #width of gaussian envelope\n    ensemble = :GOE, #could be :GUE, try it!\n    parity = +) #could be - or nothing, try it!\n\nres = 0.05\nif !on_github #hide\n    res = 0.5\nend #hide\nαs=0:0.1:4\n𝔏αs = rényi_occupation(system,\n    r_states,\n    ϵ = ϵ, \n    show_progress = false, #hide\n    symmetricQP = true, # in Q because defined parity, in P because GOE\n    res = res,\n    α = αs)\nav_𝔏αs = [mean(𝔏α) for 𝔏α in 𝔏αs]\n\nplot(αs,av_𝔏αs,\n    key = false,\n    ylabel = \"⟨𝔏α⟩\",\n    xlabel = \"α\",\n    guidefont = \"times\")\nsavefig(\"randomStatesL.svg\");nothing #hide","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"(Image: )","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"The form of this plot is precisely Eq. (18) of Ref. [15]. ","category":"page"},{"location":"EnergyShellProjectionsExamples/","page":"EnergyShellProjections","title":"EnergyShellProjections","text":"tip: Tip\nIf you plan to compute both  EnergyShellProjections.rényi_occupation and EnergyShellProjections.proj_husimi_QP_matrix, you should use the  combined call  EnergyShellProjections.rényi_occupation_and_proj_husimi_QP_matrix, which computes them both in the same routine and is faster than calling them separately.","category":"page"},{"location":"TWAExamples/#Examples-for-TWA","page":"TWA","title":"Examples for TWA","text":"","category":"section"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\ncache_fold_name=\"./diags\"\nuse_current_dir_for_diags=on_github\nusing DickeModel","category":"page"},{"location":"TWAExamples/#Classical-evolution-of-coherent-states","page":"TWA","title":"Classical evolution of coherent states","text":"","category":"section"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"The module DickeModel.TWA is a very powerful tool to study the classical evolution of distributions in the phase space.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"Let us load the module DickeModel.TWA, together with Distributed which allows parallelization.  ","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"@info \"Starting example: TWA\"","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"using Distributed\nusing Plots,Plots.PlotMeasures\nusing DickeModel.TWA\nusing DickeModel.ClassicalDicke\nif false #hide\naddprocs(2) #we add 2 workers. Add as many as there are cores in your computer.\n@everywhere using DickeModel\nend #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"The functions from DickeModel.TWA will make use of all the available workers.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"note: Note\nThe line @everywhere using DickeModelis necessary to load the module DickeModel in all workers. You will get errors if you omit it.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"For our first example, let us consider the Wigner function of a coherent state, evolve it classically using the truncated Wigner approximation (TWA) (see Refs. [19], [12]), and then look at  the expected value of the Weyl symbol  of the observable hatj_z=hatJ_zj in time with  TWA.average. Note the usage of Weyl.Jz.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"@info \"Starting example: TWA jz\"","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"system = ClassicalDickeSystem(ω=1.0, γ=1.0, ω₀=1.0)\nx = Point(system, Q=1, P=1, p=0, ϵ=0.5)\nj = 300\nW = coherent_Wigner_HWxSU2(x,j=j)\njz = Weyl.Jz(j)/j \ntimes = 0:0.05:40\nif !on_github  times=0:1:4 end #hide\n\nN = 20000\nif !on_github N=200 end #hide\njz_average = average(system; \n    observable = jz, \n    show_progress = false, #hide\n    distribution = W, \n    N = N, \n    ts=times)\nplot(times,jz_average, xlabel=\"time\", \n    ylabel=\"jz\",key=false,ylim=(-1,1), size=(700,350))\nsavefig(\"average_jz_TWA.svg\");nothing #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"(Image: )","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"Okay, but we can do more. Let's see how the whole distribution of j_z evolves classically using TWA.calculate_distribution.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"@info \"Starting example: jz distribution\"","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"y_axis_values = -1.1:0.01:1.1\nmatrix = calculate_distribution(system; \n    distribution = W, \n    N = N,\n    x=:t,  \n    show_progress=false, #hide\n    ts = times,\n    y = jz, \n    ys = y_axis_values)\nheatmap(times, y_axis_values, matrix,\n    size=(700,350), color=cgrad(:gist_heat, rev=true),\n    xlabel=\"time\", ylabel=\"jz\")\nsavefig(\"distribution_jz_TWA.svg\");nothing #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"(Image: )","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"See this example for a comparison between exact quantum evolution and TWA.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"We can chain several computations using TWA.mcs_chain.  For example, let's see the evolution of q and p for the same coherent state evolving in time, along with the time-averaged distribution in the plane qp.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"@info \"Starting example: TWA qp\"","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"qs = -4.3:0.02:4.3\nps = -2.4:0.02:2.4\nif !on_github  qs=-4.2:0.5:4.2;ps=-2.4:0.5:2.4 end #hide\nN = 50000\nif !on_github N=200 end #hide\n\nmcs=mcs_chain(\n    mcs_for_distributions(\n        system; N = N, \n        distribution=W,\n        y=:t,  ts=times,\n        x=:q, xs=qs),\n    mcs_for_distributions(\n            system; N = N,\n            distribution=W,\n            y=:p, ys=ps,\n            x=:t,  ts=times),\n    mcs_for_distributions(\n        system; N = N,\n        distribution=W,\n        x=:q,  xs=qs,\n        y=:p, ys=ps,ts=times)\n)\nmatrix_q_vs_t, \nmatrix_t_vs_p, \nmatrix_q_vs_p = monte_carlo_integrate(system, \n                      mcs;\n                      ts = times,\n                      N = N,\n                      show_progress = false, #hide\n                      distribution = W)\n\n    \nplot(heatmap(qs,times, matrix_q_vs_t,\n        color=cgrad(:gist_heat, rev=true),\n        ylabel=\"time\", xlabel=\"q\", xmirror =true, \n        ymirror =true, bottom_margin = -15mm),\n    heatmap(times,ps, matrix_t_vs_p,\n        color=cgrad(:gist_heat, rev=true),\n        xlabel=\"time\", ylabel=\"p\", right_margin = -15mm),\n    heatmap(qs,ps, matrix_q_vs_p,\n        color=cgrad(:gist_heat, rev=true),\n        ticks=:none,size=(400,400),margin = -15mm),\n    layout=(@layout [_ °; \n                     ° °]), \n    color=cgrad(:gist_heat, rev=true),\n    size=(800,800),colorbar=:none,link=:both)\nsavefig(\"distribution_qptime_TWA.svg\");nothing #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"(Image: )","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"The function calculate_distribution can even animate the evolution (with a little help from the wonderful @animate from Plots).","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"@info \"Starting example: TWA qp animation\"","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"N = 200000\nqs = -4.3:0.04:4.3\nps = -2.4:0.04:2.4\nif !on_github  qs=-4.2:0.5:4.2;ps=-2.4:0.5:2.4 end #hide\n\ntimes = 0:0.1:40\nif !on_github N=200 end #hide\nif !on_github times=0:1 end #hide\n\nmatrices = calculate_distribution(system; \n    distribution=W, \n    N = N,\n    x = :q, \n    y = :p,\n    xs = qs, \n    ys = ps, \n    ts = times, \n    show_progress = false, #hide\n    animate = true)\nanimation=@animate for mat in matrices\n    heatmap(qs, ps, mat,\n        color = cgrad(:gist_heat, rev=true), size=(600,600), \n        xlabel=\"q\", ylabel=\"p\", key=false)\nend\nmp4(animation,\n    \"animation_of_evolution.mp4\",\n    show_msg=false, #hide\n    fps=30)\nnothing; #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"(Image: )","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"note: Note\nComputing animations with calculate_distribution(..., animate = true, ...) may need a lot of RAM. You can estimate the maximum amount of RAM needed using the shorthand formula  (text of workers) times (textlength of  xs )times (textlength of  ys )times (textlength of  ts ) times (64 text bits).But this number would only be reached if trajectories filled all of the matrices in all of the workers at all the timesteps. You may stay much below this number by passing maxNBatch to calculate_distribution (or to  monte_carlo_integrate). This parameter limits the number of trajectories that are calculated in batch in each  worker. Between batches, data is flushed to the main worker, which takes time, but liberates RAM.  If generating the animation is filling up your RAM, try to decrease maxNBatch.","category":"page"},{"location":"TWAExamples/#TWAvsQuantum","page":"TWA","title":"TWA vs exact quantum evolution","text":"","category":"section"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"Let us compare the evolution of a quantum state with that given by the TWA. ","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"We select a point in the phase space and load the Wigner function of a coherent state centered at that point using TWA.coherent_Wigner_HWxSU2","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"@info \"Starting example: Quantum vs TWA\"","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"using Plots\nusing DickeModel.TWA\nusing DickeModel.DickeBCE, DickeModel.ClassicalDicke\nusing LinearAlgebra\nj = 30\nsystem = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j = j, Nmax=120)\nif false #hide\neigenenergies,eigenstates = diagonalization(system) \nend #hide\nif !use_current_dir_for_diags #hide\neigenenergies,eigenstates =  diagonalization(system,verbose=false) #hide\nelse #hide\neigenenergies,eigenstates =  diagonalization(system, cache_folder=cache_fold_name,verbose=false)  #hide\nend #hide\n\nx = Point(system, Q=1.75, P=0, p=0, ϵ=-0.5)\ncoh_state=coherent_state(system, x)\nW = coherent_Wigner_HWxSU2(x,j=j)\nnothing #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"First, we compare the expectation value of the observable hatJ_z^2. We load its Weyl symbol using Weyl.Jz²(j), and its matrix form in the BCE using DickeBCE.Jz(system)^2.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"ts= 0:0.05:40\nevolution = evolve(ts, coh_state, \n                eigenstates=eigenstates,\n                eigenenergies=eigenenergies);\nJz²=DickeBCE.Jz(system)^2\n\n               #〈 v｜Jz²｜v 〉for each column v in evolution\nexvals = [real(dot(v, Jz² ,v)) for v in eachcol(evolution)]\n\nN=20000\nif !on_github N=1000 end #hide\nTWAJz2 = TWA.average(system,\n                 distribution = W,\n                 show_progress=false, #hide\n                 observable = Weyl.Jz²(j), \n                 ts = ts,\n                 N = N)\n\nplot(ts, [exvals TWAJz2], \n    size=(700,350), label=[\"Quantum\" \"TWA\"],\n    left_margin=2Plots.mm,\n    xlabel = \"time\", ylabel=\"Jz²\")\nsavefig(\"Jz2_QvsTWA.svg\");nothing #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"(Image: )","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"Now let us take a look at the survival probability (see Ref. [19]). We use the function DickeBCE.survival_probability to compute the exact survival probability, and TWA.survival_probability gives us the result from the TWA.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"ts=exp10.(-2:0.01:3)\n\nN=20000 # Higher values reduce numerical noise at the cost of speed\nif !on_github N=1000 end #hide\nclassical_SP = TWA.survival_probability(\n    system; \n    distribution = W,\n    show_progress=false, #hide\n    N=N, ts=ts\n)\nquantum_SP = DickeBCE.survival_probability(\n    ts,\n    state=coh_state, \n    eigenstates=eigenstates, \n    eigenenergies=eigenenergies\n)\n\nplot(ts, [quantum_SP classical_SP], \n    yscale=:log10, xscale=:log10, \n    ylim=(1e-4,1), label=[\"Quantum\" \"TWA\"], \n    xlabel=\"time\", ylabel=\"Survival probability\")\nsavefig(\"SP_QvsTWA.svg\");nothing #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"(Image: )","category":"page"},{"location":"TWAExamples/#Fidelity-out-of-time-order-correlator-(FOTOC)","page":"TWA","title":"Fidelity out-of-time order correlator (FOTOC)","text":"","category":"section"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"The FOTOC is a quantum equivalent of the classical Lyapunov exponent. It is just the variance textvar(Q)+textvar(q)+textvar(P)+textvar(p) as a function of time. It may be calculated using the TWA with TWA.variance. See Ref. [12] and references therein.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"@info \"Starting example: TWA FOTOC Dicke\"","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"using DickeModel.ClassicalDicke\nusing DickeModel.ClassicalSystems\nusing DickeModel.TWA\nusing Plots\nsystem = ClassicalDickeSystem(ω=1.0, γ=1.0, ω₀=1.0)\n\nts = 0:0.1:50\nj = 1000\nx = Point(system, Q=1, P=0, p=0, ϵ=-0.6)\nW = coherent_Wigner_HWxSU2(x, j=j)\nN = 10000\nif !on_github N=200 end #hide\nif !on_github times=0:1:10 end #hide\n\nFOTOC=sum.(\n    variance(system; \n        observable = [:Q,:q,:P,:p], \n        distribution = W, \n        N=N, \n        ts=ts, \n        show_progress = false, #hide\n        tol=1e-8)\n            )\n\nplot(ts, FOTOC, \n     xlabel=\"time\", ylabel=\"FOTOC\",\n     label=\"FOTOC\", yscale=:log10)\nif false #hide\nlyapunov = lyapunov_exponent(system, x)\nelse #hide\nlyapunov = lyapunov_exponent(system, x; verbose = false) #hide\nend #hide\nplot!(t->exp(2*lyapunov*t)*2/j, 0, 14, \n    label=\"exp(2λt)*2ħ\", key=:bottomright)\nsavefig(\"FOTOC_TWA.svg\");nothing #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"(Image: )","category":"page"},{"location":"TWAExamples/#semiclassicalLDoS","page":"TWA","title":"Energy profiles of a coherent state","text":"","category":"section"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"The functions in this module may be useful even when there is no time evolution. We have a semiclassical formula for the energy width of a coherent state, given in App. A of Ref. [7], and implemented in DickeBCE.energy_width_of_coherent_state. Let's check this formula against the semiclassical local density of states given by Eq. (E.3) of Ref. [19], which we may compute using TWA.calculate_distribution.","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"@info \"Starting example: Semiclassical LDoS\"","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"using DickeModel.ClassicalDicke\nusing DickeModel.ClassicalSystems\nusing DickeModel.TWA\nusing DickeModel.DickeBCE\nusing Distributions\nusing Plots\nj = 1000\nsystem = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j = j)\n\nts = 0:0.1:50\nϵₓ = -0.5\nx = Point(system, Q=-1, P=0, p=0, ϵ=ϵₓ)\nW = coherent_Wigner_HWxSU2(x, j=j)\nN = 500000\n\nϵ_binsize = 0.02\nif !on_github N=1000 end #hide\nif !on_github ϵ_binsize=0.1 end #hide\n\nϵs = -0.8:ϵ_binsize:0\nρ = calculate_distribution(system, \n    distribution = W, \n    N = N, \n    show_progress = false, #hide\n    x = ClassicalDicke.hamiltonian(system), \n    xs = ϵs)'\nρ /= sum(ρ)*ϵ_binsize #normalization\nσₓ = energy_width_of_coherent_state(system, x)\ngaussian=Distributions.Normal(ϵₓ, σₓ)\n\nplot(ϵs,ρ, label=\"∫ w(x) δ(ϵ - h(x)) dx\")\nplot!(ϵ->pdf(gaussian,ϵ), ϵs, \n    label=\"normal(σ)\", linestyle=:dash,\n    xlabel=\"ϵ\", ylabel=\"Probability density\")\nsavefig(\"LDoS_classical.svg\");nothing #hide","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"(Image: )","category":"page"},{"location":"TWAExamples/","page":"TWA","title":"TWA","text":"See this example for the full quantum computation of the energy spectrum of a coherent state.","category":"page"},{"location":"UPOsExamples/#Examples-for-UPOs","page":"UPOs","title":"Examples for UPOs","text":"","category":"section"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\ncache_fold_name=\"./diags\"\nuse_current_dir_for_diags=on_github\nusing DickeModel","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"The module DickeModel.UPOs provides a toolbox for studying periodic orbits (POs)  in the classical limit of the Dicke model [13], and their relation with the ubiquitous quantum scarring they produce [14].","category":"page"},{"location":"UPOsExamples/#The-fundamental-families-of-periodic-orbits","page":"UPOs","title":"The fundamental families of periodic orbits","text":"","category":"section"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"In Ref. [12], it was shown that two families of periodic orbits emanate from the normal modes of the ground state configuration of the classical Dicke model. These families are called family mathcalA and family mathcalB. They are implemented in UPOs.family_A and UPOs.family_B, respectively. Let us look at family mathcalA.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: Family A\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"using Plots\nplotly() #first call generates an info message that we want to hide","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"using DickeModel\nusing DickeModel.UPOs\nusing DickeModel.ClassicalDicke\nusing Plots\nplotly() #interactive plots\nPlots.isijulia() = true #hide\n\nsystem = ClassicalDickeSystem(ω=1.0, γ=1.0, ω₀=1.0)\nfam_A = UPOs.family_A(system)\nfam_A = UPOs.family_A(system, verbose=false) #hide\nnothing; #hide","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"You may retrieve the PO at a given energy epsilon by calling fam_A(ϵ),","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"po = fam_A(-0.5)","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Having an instance of PO, you may extract many properties  of the periodic orbit:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"UPOs.lyapunov(po) #Lyapunov exponent \npo.T #period\nUPOs.action(po) #action\nUPOs.jz_PO_average(po) #average of jz along orbit","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Let us plot the orbits of mathcalA from the ground state energy up to epsilon = 0. Using QPp, we may extract the coordinates (QPp) and then simply pass them to plot! to generate a 3D plot. We also draw the mirrored family widetildemathcalA (see  [12]), which we obtain by applying  mirror_Qq.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"ϵ₀ = minimum_energy(system)\n\norbits_plot = plot(xlabel=\"Q\", ylabel=\"P\", zlabel=\"p\", size=(800,500))\n\nenergies = ϵ₀:0.1:0\nfor ϵ in energies\n    plot!(orbits_plot, QPp(fam_A(ϵ)), \n        label = \"ϵ = $(round(ϵ,digits=3))\") \n    plot!(orbits_plot, QPp(mirror_Qq(fam_A(ϵ))), \n        label = \"ϵ = $(round(ϵ,digits=3))\",\n        primary=false,linestyle=:dot) #mirrored orbit\n\nend\ngr() #hide\norbits_plot","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Plots.isijulia() = false ","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Now try with family mathcalB!","category":"page"},{"location":"UPOsExamples/#Finding-periodic-orbits-with-the-Husimi-function-of-the-eigenstates","page":"UPOs","title":"Finding periodic orbits with the Husimi function of the eigenstates","text":"","category":"section"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"In this example, we will find a family of periodic orbits by looking at the scars it produces in a quantum eigenstates. This procedure was used in Ref. [15] with  j=100. In this example we will work with a smaller system size of j=30.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"First, let us setup our quantum system.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: UPOS from Husimi\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"using DickeModel\nusing DickeModel.DickeBCE\nusing DickeModel.ClassicalDicke\nusing DickeModel.EnergyShellProjections\nusing Plots\n\nj = 30\nNmax = 120\nsystem = QuantumDickeSystem(ω=1.0, γ=1.0, ω₀=1.0, j = j, Nmax=120)\n\nif false #hide\neigenenergies,eigenstates = diagonalization(system) \nend #hide\nif !use_current_dir_for_diags #hide\neigenenergies,eigenstates =  diagonalization(system,verbose=false) #hide\nelse #hide\neigenenergies,eigenstates =  diagonalization(system, cache_folder=cache_fold_name,verbose=false)  #hide\nend #hide\nϵs = eigenenergies/j\nnothing; #hide","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"If you want to speed up the computation of the Husimi projections, you may load more modules:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"using Distributed\naddprocs(4) #you may add as many as processors in your computer\n@everywhere using DickeModel","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"In Ref. [15] it was found that the following procedure yields periodic orbits for eigenstates with a low value of the Rényi occupation. Having looked at the occupations for many eigenstates beforehand, we selected k = 559. You can use EnergyShellProjections.rényi_occupation to compute the  Rényi occupation of many eigenstates and then select those with low values yourself (see Ref. [15] for more details.)","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Let's take a look at its Husimi projection using EnergyShellProjections.proj_husimi_QP_matrix.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: UPOS from Husimi, plot\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"k = 559\nstate = @view eigenstates[:,k]\nres = 0.04\nif !on_github #hide\n    res = 0.1 #hide\nend #hide\nQs,Ps,mat = proj_husimi_QP_matrix(system, \n    state, \n    ϵ = ϵs[k], \n    res = res, \n    show_progress = false, #hide\n    symmetricQP = true, \n    chop = 1e-2)\nheatmap(Qs, Ps, mat, xlabel=\"Q\", ylabel=\"P\")","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"It has a nice scar-like shape. Let us find the periodic orbit that is generating  this scar. To do this, we will increase the moment of the Husimi function, allowing us to better identify the scar. Also, the projection above is a sum of both the positive and negative q sides of the energy shell, but it is easier to stay only on one side, so let us stay only the positive q solution, loosing the symmetry in Q. We add arguments matrix_powers, onlyqroot, and symmetricP (not symmetricQP):","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: UPOS from Husimi, half plot\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Qs₊, Ps₊, mat₊ = proj_husimi_QP_matrix(system, \n    state, \n    ϵ = ϵs[k],\n    show_progress = false, #hide\n    matrix_powers=2, \n    res = res, \n    symmetricP = true, \n    chop = 1e-2,\n    onlyqroot = +)\n\nheatmap(Qs₊, Ps₊, mat₊, xlabel=\"Q\", ylabel=\"P\")","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Okay, the procedure is to identify the peaks in this matrix. Let us define a function that finds peaks in a matrix:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: UPOS from Husimi, peaks\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"function find_2D_peaks(mat)\n    pks=[] #a list to save the peaks\n    ny,nx = size(mat) #dimentions of the matrix\n    for x in 2:(nx-1), y in 2:(ny-1) #for each internal point\n            if isnan(mat[y,x]) #if is outside  we skip\n                continue\n            end\n            #If any of the neighboring coordinates has a\n            #greater value, we skip\n            if any(!isnan(mat[y+j,x+i]) && mat[y,x]<mat[y+j,x+i] \n                for (i,j) in [(1,0),(0,1),(-1,0),(0,-1)])\n                continue\n            end\n            #if we got to here, habemus peak: \n            push!(pks,[x,y])\n    end\n    #We sort the peaks by their intensity\n    pks = sort!(pks, by = a ->  mat[a[2],a[1]], rev=true)\n    return pks\nend\nnothing; #hide","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Lets apply this function to mat₊:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"#we take only the first 19 peaks: there are many small ones!\npeaks = find_2D_peaks(mat₊)[1:19] \npeaks_plot = heatmap(Qs₊, Ps₊, mat₊, \n    key=false, xlabel=\"Q\", \n    ylabel=\"P\", size=(700,500))\n    \nfor peak in peaks\n    Q,P = Qs₊[peak[1]], Ps₊[peak[2]]\n    scatter!([(Q,P)], \n        series_annotations = text(\"$((round(Q,digits=5),round(P,digits=5)))  \", \n                                    :white, :right, 7)\n        )\nend\npeaks_plot","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"We have many peaks. They idea is to try to use them as initial conditions for our periodic orbit. We have to choose one peak, and identify the coordinates for  p. There are many choices, and you will have to do some trial and error. Let us select the peak at Q=008 P=06. This one will work. ","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"To identify the coordinate of the peak in  p, we will find the local maxima of the Husimi function with varying  p. To do this, we will use  Optim.jl","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: UPOS from Husimi, optim\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"using Optim\nQ0=0.08\nP0=0.6\n\n#this function gives the Husimi function of the state evaluated at the\n#point [Q,q,P,p], where q is on the + side of the energy shell. If\n#the point is outside the energy shell, it returns 0.\nfunction hus(;p,Q,P)\n    let point\n        try \n            point=Point(system, Q=Q, P=P, p=p, ϵ=ϵs[k], sgn=+)\n        catch #the point is outside the energy shell.\n            return 0\n        end\n\n        return DickeBCE.husimi(system,point,state,chop=1e-3)\n    end\nend\n\n#let's vary the p coordinate\nh(p) = hus(p=p, Q=Q0, P=P0)\nplot(h, -2, 2, label=\"Husimi(Q0,P0,p,q₊)\", xlabel=\"p\")\n#we find a local maxima between -2 and 2 (you may move this to \n#    identify the peaks you want)\npmax = Optim.maximizer(maximize(h,-2,2))\n\nplot!([pmax,pmax], [0,h(pmax)], label = \"pmax=$pmax\")","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Okay, we now have our coordinates QPp. Before using them as initial conditions,  recall that we got QP from our projection, which did not have the best of the resolutions. We can refine them a little better by maximizing the Husimi function varying both P and p:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"pmax1, P1 = Optim.maximizer(maximize(x -> hus(p=x[1], P=x[2], Q=Q0), [pmax,P0]))","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"We now can define an initial condition","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"u0 = Point(system, Q=Q0, P=P1, p=pmax1, ϵ=ϵs[k])","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Let us first see how the evolution of this point looks like with ClassicalSystems.integrate. Let's evolve it for, say, T = 10:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: UPOS from Husimi, evolution test\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"heatmap(Qs, Ps, mat, xlabel=\"Q\", ylabel=\"P\", key=false)\nscatter!([(u0[1],u0[3])])\nplot!(integrate(system, u0, 10), vars=(:Q,:P))\nplot!(xlim=(Qs[1],Qs[end])) #hide","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"It looks like it is following the scar. ","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"It is time to use the module UPOs to help us estimate a period.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"using DickeModel.UPOs\nnothing; #hide","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"We can use UPOs.approximate_period. We give it a bound = 0.5, and it will tell us the time it takes for the periodic condition to come back to the same p plane inside a neighborhood of radius bound around u0:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"T = UPOs.approximate_period(system, u0; bound=0.5)","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"It found a period! The evolution up to that period looks like this:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"heatmap(Qs, Ps, mat, xlabel=\"Q\", ylabel=\"P\", key=false)\nscatter!([(u0[1],u0[3])])\nplot!(integrate(system, u0, T), vars=(:Q,:P))\nplot!(xlim=(Qs[1],Qs[end])) #hide","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Well, it doesn't come back completely, and it looks a bit wonky, but the monodromy method [1], [6], [13], [17] will come to our aid. This algorithm converges to a true periodic orbit given a good enough initial guess, like ours. It is implemented in UPOs.monodromy_method_constant_energy, which conserves the energy of the initial condition.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: UPOS from Husimi, monodromy\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"po = monodromy_method_constant_energy(system, u0, T)","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"heatmap(Qs, Ps, mat, xlabel=\"Q\", ylabel=\"P\", key=false)\nscatter!([(po.u[1],po.u[3])])\nplot!(QP(po))","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"That is a nice periodic orbit!","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"We can measure that it is actually scarring the eigenstate using the measure mathcalP from Ref. [13], which is implemented in UPOs.scarring_measure:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"scarring_measure(po,state)","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"This tells us that the state is sim 12 times more likely to be found near the PO than a totally delocalized state.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"We can also compute its Lyapunov exponent using UPOs.lyapunov:","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"lyapunov(po)","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Interestingly, this orbit is stable, with a zero Lyapunov exponent. However, the eigenenergy of this eigenstate, epsilon_k = -0806 is in the chaotic region, so we found a little island of stability in the sea of chaos.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Moreover, this orbit is symmetric with respect to the change of parity (Qq)mapsto (-Q-p):","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"mirror_Qq(po) == po","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"note: Note\nThe method po1 == po2 actually checks whether the orbits are equal by integration. The comparison po1 == po2 is true if the orbits are the same, even if po1.u != po2.u.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"We close this example using the function UPOs.follow_PO_family_from_energy to perturb this orbit into higher energies, obtaining a family of POs.","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: UPOS from Husimi, family plot\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"plotly() #interactive plots\nPlots.isijulia() = true #hide\nfamily = follow_PO_family_from_energy(po)\norbits_plot = plot(xlabel=\"Q\", ylabel=\"P\", zlabel=\"p\", size=(800,600))\nenergies = -0.8:0.03:0\nfor ϵ in energies\n    plot!(orbits_plot, QPp(family(ϵ)), label = \"ϵ = $ϵ\") \nend\ngr() #hide\norbits_plot","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"Plots.isijulia() = false ","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"This family of UPOs seems to contain the UPO mathcalO_textB from Ref. [15]. See Fig 3. (B2).","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"We can see how the stability of this family changes as a function of the energy (like Fig. 1 of Ref. [13]):","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"@info \"Starting example: UPOS from Husimi, family Lyapunov\"","category":"page"},{"location":"UPOsExamples/","page":"UPOs","title":"UPOs","text":"energies = -0.8:0.01:0\nplot(energies, lyapunov.(family.(energies)),\n    xlabel=\"energy\", ylabel=\"Lyapunov exponent\", key = false)","category":"page"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces","text":"","category":"section"},{"location":"PhaseSpaces/","page":"PhaseSpaces","title":"PhaseSpaces","text":"This module provides formulas for the cannonical transformation (QP)mapsto (thetaphi)  we use throughout this package. ","category":"page"},{"location":"PhaseSpaces/","page":"PhaseSpaces","title":"PhaseSpaces","text":"note: Note\nThere is an unfortunate problem between the characters phi (\\phi) and varphi (\\varphi): some fonts render one as the other.  To avoid errors, the functions below treat the two characters indistinctly.  In the references, the glyph phi is used.","category":"page"},{"location":"PhaseSpaces/","page":"PhaseSpaces","title":"PhaseSpaces","text":"Modules = [DickeModel.PhaseSpaces]\nOrder   = [:type,:function]","category":"page"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.P_of_θφ-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.P_of_θφ","text":"See P_of_θϕ.\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.P_of_θϕ-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.P_of_θϕ","text":"function P_of_θϕ(θ,ϕ)\n\nReturns\n\n    P=- sqrt2 (1 - cos(theta))sin(phi)\n\nAlso P_of_θφ(θ,φ).\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.Q_of_θφ-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.Q_of_θφ","text":"See Q_of_θϕ.\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.Q_of_θϕ-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.Q_of_θϕ","text":"function Q_of_θϕ(θ,ϕ)\n\nReturns\n\n    Q=sqrt2 (1 - cos(theta))cos(phi)\n\nAlso Q_of_θφ(θ,φ).\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.arc_between_QP-NTuple{4, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.arc_between_QP","text":"function arc_between_QP(Q1,P1,Q2,P2)\n\nReturns \n\n    arc_between_θϕ(θ_of_QP(Q1,P1),ϕ_of_QP(Q1,P1),θ_of_QP(Q2,P2),ϕ_of_QP(Q2,P2)).\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.arc_between_θφ-NTuple{4, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.arc_between_θφ","text":"See arc_between_θϕ.\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.arc_between_θϕ-NTuple{4, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.arc_between_θϕ","text":"function arc_between_θϕ(θ1,φ1,θ2,φ2)\n\nReturns \n\n    Theta = arccos(cos(theta_1)cos(theta_2)+ sin(theta_1)sin(theta_2)cos(phi_1 - phi_2))\n\nAlso arc_between_θφ(θ1,φ1,θ2,φ2).\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.jx-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.jx","text":"function jx(Q,P)\n\nReturns\n\n    j_x = sin(theta(QP))cos(phi(QP))\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.jy-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.jy","text":"function jy(Q,P)\n\nReturns \n\n    j_y = sin(theta(QP))sin(phi(QP))\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.jz-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.jz","text":"function jz(Q,P)\n\nReturns\n\n    j_z = -  cos(theta(QP))\n\nwhere textarctan2 is the 2-argument arctangent.\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.θ_of_QP-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.θ_of_QP","text":"function θ_of_QP(Q,P)\n\nReturns\n\n    theta =- arccosleft(1 - fracQ^2 + P^22right)\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.φ_of_QP-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.φ_of_QP","text":"See ϕ_of_QP.\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#DickeModel.PhaseSpaces.ϕ_of_QP-Tuple{Real, Real}","page":"PhaseSpaces","title":"DickeModel.PhaseSpaces.ϕ_of_QP","text":"function ϕ_of_QP(Q,P)\n\nReturns\n\n    phi = textarctan2(-PQ)in 02 pi \n\nwhere textarctan2 is the 2-argument arctangent.\n\nAlso φ_of_QP(Q,P).\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke","text":"","category":"section"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"For examples of usage, go to  Examples for ClassicalDicke.","category":"page"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"CurrentModule = DickeModel.ClassicalDicke","category":"page"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"DickeSystem\nClassicalDickeSystem\nhamiltonian","category":"page"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.DickeSystem","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.DickeSystem","text":"abstract type DickeSystem <: ClassicalSystems.ClassicalSystem\n\nAbstract subtype of ClassicalSystems.ClassicalSystem which represents the classical Dicke model. To generate it, use the concrete subtypes ClassicalDickeSystem or DickeBCE.QuantumDickeSystem.\n\n\n\n\n\n","category":"type"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.ClassicalDickeSystem","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.ClassicalDickeSystem","text":"struct ClassicalDickeSystem <: DickeSystem\n\nSubtype of ClassicalSystems.ClassicalSystem which represents the classical Dicke model with the given parameters ω_0, ω, and γ. See Eq. (5) of Ref. [13]. To generate this struct, use the constructor\n\nClassicalDickeSystem(;ω₀::Real,ω::Real,γ::Real)\n\nFor example, system = ClassicalDickeSystem(ω₀=1, ω=1, γ=1).\n\nThis struct may be passed to all functions in this module that require an instance of DickeSystem, as well as functions in other modules that require ClassicalSystems.ClassicalSystem,  such as  ClassicalSystems.integrate.\n\n\n\n\n\n","category":"type"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.hamiltonian","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.hamiltonian","text":"function hamiltonian(system::DickeSystem)\n\nReturns a classical Hamiltonian function h(x) where x=[Q,q,P,p], which is given by Eq. (5) of Ref. [13].\n\nArguments\n\nsystem should be a subtype of DickeSystem.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Phase-space","page":"ClassicalDicke","title":"Phase space","text":"","category":"section"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"Point\nPointθϕ\nenergy_shell_volume\nphase_space_dist_squared\nclassical_path_random_sampler","category":"page"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.Point","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.Point","text":"function Point(;Q::Real,q::Real,P::Real,p::Real)\n\nReturns the array [Q,q,P,p]. This ordering is used throughout this package.\n\n\n\n\n\nfunction Point(system::DickeSystem;\n    Q::Real,\n    P::Real,\n    p::Real,\n    ϵ::Real,\n    sgn::Union{typeof(-),typeof(+)} = +)\n\nReturns a list [Q,q,P,p], where q is calculated with ClassicalDicke.q_of_ϵ.  If there are no solutions for q, an error is raised.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.Pointθϕ","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.Pointθϕ","text":"function Pointθϕ(;θ::Real,ϕ::Real,q::Real,p::Real)\n\nReturns a list [Q,q,P,p], where Q and P are calculated from θ and ϕ using PhaseSpaces.Q_of_θϕ and  PhaseSpaces.P_of_θϕ.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.energy_shell_volume","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.energy_shell_volume","text":"function energy_shell_volume(system::DickeSystem,ϵ::Real)\n\nReturns the volume of the classical energy shell in the phase space, that is,\n\nmathcalV(mathcalM_ϵ) = int_mathcalM textdmathbfx  delta(h_textcl(mathbfx)- epsilon)\n\nThis is computed using a modified version of Eq. (A2) in [15], (the integral is  performed in the variable Q instead of y). That equation was originally derived in Ref. [3], with different units for epsilon. \n\nThe integration is performed using QuadGK.\n\nArguments\n\nsystem should be a subtype of DickeSystem.\nϵ is the energy.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.phase_space_dist_squared","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.phase_space_dist_squared","text":"function phase_space_dist_squared(x::AbstractVector{<:Real},y::AbstractVector{<:Real})\n\nReturns the phase-space distance d_mathcalM(mathbfxmathbfy) (See App. C of Ref [13]), where x and y are vectors in the form [Q,q,P,p].\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.classical_path_random_sampler","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.classical_path_random_sampler","text":"function classical_path_random_sampler(system::DickeSystem; ϵ::Real, dt::Real=3)\n\nThis function returns a function sample(), which produces random points within the classical energy shell at energy ϵ. The function sample() returns points from a fixed chaotic  trajectory picked at random separated by a fixed time interval  dt. If the classical dynamics are ergodic,  which only happens in chaotic regions, this produces random points in the energy shell.\n\nArguments\n\nsystem should be a subtype of DickeSystem.\n\nKeyword arguments\n\nϵ is the energy of the energy shell from where to sample.\ndt is the fixed time interval that separates the points that are returned by sample().\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Energy-minimizing","page":"ClassicalDicke","title":"Energy minimizing","text":"","category":"section"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"minimum_energy\nminimum_ϵ_for\nminimum_energy_point\nnormal_frequency","category":"page"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.minimum_energy","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.minimum_energy","text":"function minimum_energy(system::DickeSystem)\n\nReturns the ground-state energy, as given by multiplying Eq. (15) of Ref. [3] by omega_0 (because in that work they use epsilon =E(omega_0 j), and in this module we use epsilon = Ej).\n\nArguments\n\nsystem should be a subtype of DickeSystem.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.minimum_ϵ_for","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.minimum_ϵ_for","text":"function minimum_ϵ_for(system::DickeSystem;\n    Q::Union{Real,Nothing}=nothing,\n    q::Union{Real,Nothing}=nothing,\n    P::Union{Real,Nothing}=nothing,\n    p::Union{Real,Nothing}=nothing)\n\nReturns the minimum energy epsilon when constraining the system to three fixed values of the coordinates Q, q, P, p.\n\nArguments\n\nsystem should be a subtype of DickeSystem.\n\nKeyword arguments\n\nYou may pass either (QqP) or (qPp). The other combinanations are not implemented.\n\nThis function can be especially useful to draw contours of the available phase space (see Drawing contours of the available phase space)\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.minimum_energy_point","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.minimum_energy_point","text":"function minimum_energy_point(system::DickeSystem,\n    Qsign::Union{typeof(-),typeof(+)} = +)\n\nReturns the ground-state coordinate, that is,  (0, 0, 0, 0) for the normal phase and mathbfx_textGS below Eq. (7) of Ref. [13] for the superradiant phase.\n\nArguments\n\nsystem should be a subtype of DickeSystem.\nQsign toggles the sign of the Q coordinate in the superradiant phase,  that is, + for mathbfx_textGS and  - for widetildemathbfx_textGS . Defaults to +.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.normal_frequency","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.normal_frequency","text":"function normal_frequency(system::DickeSystem,\n    sgn::Union{typeof(-),typeof(+)} = +)\n\nReturns the ground-state normal frequency, that is, Omega_epsilon_textGS^AB at the bottom of page 3 of Ref. [13].\n\nArguments\n\nsystem should be a subtype of DickeSystem.\nsgn is - for Omega^A and + for Omega^B. Defaults to +.\n\nNote: This function currently only works for the supperadiant phase.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Roots-in-q","page":"ClassicalDicke","title":"Roots in q","text":"","category":"section"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"discriminant_of_q_solution\nq_of_ϵ\nq_sign\nPoint(::DickeSystem)","category":"page"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.discriminant_of_q_solution","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.discriminant_of_q_solution","text":"function discriminant_of_q_solution(system::DickeSystem; \n    Q::Real,\n    P::Real,\n    p::Real,\n    ϵ::Real)\n\nReturns the discriminant of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nwhere h_textcl is given by Eq. (5) of Ref. [13].\n\nArguments\n\nsystem should be a subtype of DickeSystem.\n\nKeyword arguments\n\nQ, P, p, and ϵ are the values of Q, P, p, and epsilon, respectively.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.q_of_ϵ","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.q_of_ϵ","text":"function q_of_ϵ(system::DickeSystem;\n    Q::Real,\n    P::Real,\n    p::Real,\n    ϵ::Real,\n    sgn::Union{typeof(-),typeof(+)}=+,\n    returnNaNonError::Bool=true)\n\nReturns the solutions q_pm of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nwhere h_textcl is given by Eq. (5) of Ref. [13].\n\nArguments\n\nsystem should be a subtype of DickeSystem.\n\nKeyword arguments\n\nQ, P, p, and ϵ are values of Q, P, p, and epsilon, respectively.\nsgn is + for q_+ and - for q_-\nIf returnNaNonError is true, then NaN is returned if there are no solutions. If it is false, and error is raised.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.q_sign","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.q_sign","text":"function q_sign(system::DickeSystem,\n    x::AbstractVector{<:Real},\n    ϵ::Real=hamiltonian(system)(x))\n\nReturns the sign of the root of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nThat is, this function returns + if q=x[2] ≈ q_of_ϵ(system;Q=x[1],P=x[3],p=x[4],ϵ=ϵ,sgn=+) and returns - if q=x[2] ≈ q_of_ϵ(system;Q=x[1],P=x[3],p=x[4],ϵ=ϵ,sgn=-).\n\nArguments\n\nsystem should be a subtype of DickeSystem.\nx is a vector in the form [Q,q,P,p].\nϵ should be the energy of x. If this is not passed, it is computed using hamiltonian(system)(x). \n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.Point-Tuple{DickeModel.ClassicalDicke.DickeSystem}","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.Point","text":"function Point(system::DickeSystem;\n    Q::Real,\n    P::Real,\n    p::Real,\n    ϵ::Real,\n    sgn::Union{typeof(-),typeof(+)} = +)\n\nReturns a list [Q,q,P,p], where q is calculated with ClassicalDicke.q_of_ϵ.  If there are no solutions for q, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Atomic-boundary-of-energy-shells","page":"ClassicalDicke","title":"Atomic boundary of energy shells","text":"","category":"section"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"push!(LOAD_PATH,\"../../src\")\nusing DickeModel.ClassicalDicke\nusing Plots\nsystem=ClassicalDicke.ClassicalDickeSystem(ω=1, γ=1, ω₀=1)\nQs=-2:0.01:2\nPs=-1.5:0.01:1.5\nϵ=-1.1\ncontour(Qs,Ps,(Q,P)-> ClassicalDicke.minimum_ϵ_for(system,p=0,P=P,Q=Q),\n    levels=[ϵ],xlabel=\"Q\",ylabel=\"P\",ylim=(-1.5,2.5),color=:black,key=false,linewidth=2,\n    title=\"Available phase space at ϵ\")\nQmin=minimum_nonnegative_Q_for_ϵ(system,ϵ)\nQmax=maximum_Q_for_ϵ(system,ϵ)\nPmax=maximum_P_for_ϵ(system,ϵ)\nplot!([(Qmin,-2),(Qmin,2)],label=\"+ minimum_nonnegative_Q_for_ϵ\",key=:top)\nplot!([(-Qmin,-2),(-Qmin,2)],label=\"− minimum_nonnegative_Q_for_ϵ\",linestyle=:dash)\n\nplot!([(Qmax,-2),(Qmax,2)],label=\"+ maximum_Q_for_ϵ\")\nplot!([(-Qmax,-2),(-Qmax,2)],label=\"− maximum_Q_for_ϵ\",linestyle=:dash)\n\nplot!([(-2,Pmax),(2,Pmax)],label=\"+ maximum_P_for_ϵ\")\ndiaplot=plot!([(-2,-Pmax),(2,-Pmax)],label=\"− maximum_P_for_ϵ\",linestyle=:dash)","category":"page"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"diaplot #hide","category":"page"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"minimum_nonnegative_Q_for_ϵ\nmaximum_Q_for_ϵ\nmaximum_P_for_ϵ","category":"page"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.minimum_nonnegative_Q_for_ϵ","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.minimum_nonnegative_Q_for_ϵ","text":"function minimum_nonnegative_Q_for_ϵ(system::DickeSystem,ϵ::Real)\n\nComputes the minimum nonnegative value of the parameter Q accessible to the system at energy epsilon.\n\nArguments\n\nsystem should be a subtype of DickeSystem.\nϵ is the energy.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.maximum_Q_for_ϵ","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.maximum_Q_for_ϵ","text":"function maximum_Q_for_ϵ(system::DickeSystem,ϵ::Real)\n\nComputes the maximum value of the parameter Q accessible to the system at energy epsilon.\n\nArguments\n\nsystem should be a subtype of DickeSystem.\nϵ is the energy.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#DickeModel.ClassicalDicke.maximum_P_for_ϵ","page":"ClassicalDicke","title":"DickeModel.ClassicalDicke.maximum_P_for_ϵ","text":"function maximum_P_for_ϵ(system::DickeSystem,ϵ::Real)\n\nComputes the maximum value of the parameter P accessible to the system at energy epsilon.\n\nArguments\n\nsystem should be a subtype of DickeSystem.\nϵ is the energy.\n\n\n\n\n\n","category":"function"},{"location":"TWA/#DickeModel.TWA","page":"TWA","title":"DickeModel.TWA","text":"","category":"section"},{"location":"TWA/","page":"TWA","title":"TWA","text":"For examples of usage, go to  Examples for TWA.","category":"page"},{"location":"TWA/","page":"TWA","title":"TWA","text":"CurrentModule = DickeModel.TWA","category":"page"},{"location":"TWA/#Monte-Carlo-systems","page":"TWA","title":"Monte-Carlo systems","text":"","category":"section"},{"location":"TWA/","page":"TWA","title":"TWA","text":"monte_carlo_integrate\nMonteCarloSystem\nmcs_chain","category":"page"},{"location":"TWA/#DickeModel.TWA.monte_carlo_integrate","page":"TWA","title":"DickeModel.TWA.monte_carlo_integrate","text":"function monte_carlo_integrate(system::ClassicalSystems.ClassicalSystem,\n    mc_system::MonteCarloSystem;\n    tolerate_errors::Bool = true,\n    show_progress::Bool = true,\n    maxNBatch::Real=Inf,kargs...)\n\nThis function is the backbone of this module. It performs a Monte Carlo integration-type procedure. The argument mc_system determines a distribution::PhaseSpaceDistribution, an integer N, and a list of times ts. This function calls an initializing function also determined by mc_system. Then, it samples N random points x from distribution, which are integrated using the Hamiltonian given by system. For each trajectory and time in ts, an operation is performed, which is determined again by mc_system. A final operation is then performed and the result is returned. This may seem a bit abstract, but it is a very flexible system. The applications are more concrete; for example, if you generate mc_system using mcs_for_averaging(... observable=f ...),  then the initial operation is to generate an array of zeroes the same length as ts. Then, for each initial condition x, the result of f(x(t)) is added to each element of the array. Finally, the array is overall divided by N and then returned. This is exactly a Monte Carlo integration of the function f(x) over the classical evolution  of the distribution.\n\nThis function uses all the available workers, but make sure to import this module in all of them.\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem.\nmc_system should be an instance of  MonteCarloSystem.\n\nKeyword arguments\n\ntolerate_errors indicates that some errors in the integration may be ignored. This is useful because sometimes a one-in-a-million numerical instability may arise, and you may want to ignore it. If more than 100 errors occur consecutively, then then the procedure is stopped. Defaults to true.\nshow_progress is a boolean that toggles the progress bar. (Default is true).\nmaxNBatch is the maximum number of batch-sizes sent to each worker. Defaults to inf.\nkargs are redirected to [ClassicalSystems.integrate].\n\n\n\n\n\n","category":"function"},{"location":"TWA/#DickeModel.TWA.MonteCarloSystem","page":"TWA","title":"DickeModel.TWA.MonteCarloSystem","text":"struct MonteCarloSystem\n\nThis object may be passed to monte_carlo_integrate. Use mcs_for_averaging,  mcs_for_variance, and mcs_for_survival_probability to generate them,  and mcs_chain to join them together.\n\n\n\n\n\n","category":"type"},{"location":"TWA/#DickeModel.TWA.mcs_chain","page":"TWA","title":"DickeModel.TWA.mcs_chain","text":"function mcs_chain(Fs::AbstractVector{MonteCarloSystem})\n\nGenerates a MonteCarloSystem by chaining together those in the array Fs = [monteCarloSystem1, monteCarloSystem2, ...]. The output of the system generated is an array that has the outputs of each system, in the same order as Fs.\n\nIf Fs may be any iterable. If it is not an AbstractVector, collect will be called on it.\n\n\n\n\n\nfunction mcs_chain(mcs1::MonteCarloSystem, mcs2::MonteCarloSystem, ...)\n\nFunctionally equivalent to mcs_chain([mcs1, mcs2, ...]).\n\n\n\n\n\n","category":"function"},{"location":"TWA/#Wigner-distribution-of-coherent-states","page":"TWA","title":"Wigner distribution of coherent states","text":"","category":"section"},{"location":"TWA/","page":"TWA","title":"TWA","text":"PhaseSpaceDistribution\ncoherent_Wigner_HW\ncoherent_Wigner_SU2\ncoherent_Wigner_HWxSU2","category":"page"},{"location":"TWA/#DickeModel.TWA.PhaseSpaceDistribution","page":"TWA","title":"DickeModel.TWA.PhaseSpaceDistribution","text":"struct PhaseSpaceDistribution\n\nThis object represents a probability distribution in the phase space. Currently, the only  implementation is through coherent_Wigner_SU2,  coherent_Wigner_HW, and coherent_Wigner_HWxSU2\n\n\n\n\n\n","category":"type"},{"location":"TWA/#DickeModel.TWA.coherent_Wigner_HW","page":"TWA","title":"DickeModel.TWA.coherent_Wigner_HW","text":"function coherent_Wigner_HW(;q₀::Real,p₀::Real,j::Real=1,ħ::Real=1/j)\n\nReturns a PhaseSpaceDistribution corresponding to the two-dimensional Wigner function of a coherent state of the Heisenberg-Weyl algebra (i.e. a standard coherent state)  centered at q₀,p₀. A value of ħ may be passed, or pass j to set ħ = 1/j. (See Eq. (B.1) of Ref. [19])\n\n\n\n\n\nfunction coherent_Wigner_HW(u₀::AbstractVector{<:Real},j::Real=1,ħ::Real=1/j)\n\nReturns `coherentWignerHW(;q₀=u₀[1], p₀=u₀[2], j=j, ħ=ħ).\n\n\n\n\n\n","category":"function"},{"location":"TWA/#DickeModel.TWA.coherent_Wigner_SU2","page":"TWA","title":"DickeModel.TWA.coherent_Wigner_SU2","text":"function coherent_Wigner_SU2(;Q₀::Real,P₀::Real,j::Real=1,ħ::Real=1/j)\n\nSimilar to coherent_Wigner_HW, but for a coherent state for the SU(2)  algebra (a Bloch coherent state).  The approximation given by Eq. (B.4) of Ref. [19] is used.\n\n\n\n\n\nfunction coherent_Wigner_SU2(u₀::AbstractVector{<:Real},j::Real=1,ħ::Real=1/j)\n\nReturns coherent_Wigner_SU2(Q₀=u₀[1], P₀=u₀[2], j=j, ħ=ħ).\n\n\n\n\n\n","category":"function"},{"location":"TWA/#DickeModel.TWA.coherent_Wigner_HWxSU2","page":"TWA","title":"DickeModel.TWA.coherent_Wigner_HWxSU2","text":"function coherent_Wigner_HWxSU2(;Q₀::Real, q₀::Real,\n                                P₀::Real, p₀::Real,\n                                j::Real=1, ħ::Real=1/j)\n\nProduces the Wigner function corresponding to the tensor product of coherent_Wigner_HW and coherent_Wigner_SU2.\n\n\n\n\n\nfunction coherent_Wigner_HWxSU2(u₀::AbstractVector{<:Real},j::Real=1,ħ::Real=1/j)\n\nReturns  coherent_Wigner_HWxSU2(Q₀=u₀[1], q₀=u₀[2], P₀=u₀[3], p₀=u₀[4], j=j, ħ=ħ).\n\n\n\n\n\n","category":"function"},{"location":"TWA/#Averages","page":"TWA","title":"Averages","text":"","category":"section"},{"location":"TWA/","page":"TWA","title":"TWA","text":"mcs_for_averaging\naverage","category":"page"},{"location":"TWA/#DickeModel.TWA.mcs_for_averaging","page":"TWA","title":"DickeModel.TWA.mcs_for_averaging","text":"function mcs_for_averaging(\n    system::ClassicalSystems.ClassicalSystem;\n    observable,\n    ts::AbstractVector{<:Real}=[0.0],\n    N::Integer,\n    distribution::PhaseSpaceDistribution)\n\nGenerates a MonteCarloSystem that computes\n\n    frac1N sum_i=1^N textobservable(mathbfx_i(t))\n\nfor each t in ts, where mathbfx_i will be sampled from distribution. The system produces an array the same size as ts, containing the result for each time.\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem,\n\nKeyword arguments\n\nobservable can a function in the form f(x::Vector) or f(x1,x2 ,..., x_n) with  n the dimension of the phase space determined by system. observable can also be an expression determining the operations between the varnames determined by system. For example, if system were a instance of ClassicalDicke.DickeSystem, then observable could be :(q+p^2 +Q), f(Q, q, P, p) = q + p^2 - Q or f(x) = x[2] + x[4]^2 - x[1], which are all equivalent. See also the submodule Weyl, which produces expressions corresponding to  the Weyl symbols of quantum observables.   Note: observable can also be an array of observables, in which case an array is returned for each time.\nts should be a sorted array of times.\nN is the number of points to sample. The bigger the more accurate.\ndistribution should be an instance of PhaseSpaceDistribution\n\n\n\n\n\n","category":"function"},{"location":"TWA/#DickeModel.TWA.average","page":"TWA","title":"DickeModel.TWA.average","text":"function average(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_averaging]]],\n    kargs...)\n\nCalls mcs_for_averaging and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"function"},{"location":"TWA/#Variances","page":"TWA","title":"Variances","text":"","category":"section"},{"location":"TWA/","page":"TWA","title":"TWA","text":"mcs_for_variance\nvariance","category":"page"},{"location":"TWA/#DickeModel.TWA.mcs_for_variance","page":"TWA","title":"DickeModel.TWA.mcs_for_variance","text":"function mcs_for_variance(\n    system::ClassicalSystems.ClassicalSystem;\n    observable,\n    ts::AbstractVector{<:Real}=[0.0],\n    N::Integer,\n    distribution::PhaseSpaceDistribution,\n    return_average::Bool = false)\n\nGenerates a MonteCarloSystem that computes the variance\n\n    frac1N sum_i=1^N textobservable^2(mathbfx_i(t)) - left (frac1Nsum_i=1^N textobservable(mathbfx_i(t))right )^2\n\nfor each t in ts, where mathbfx_i will be sampled from distribution. The system produces an array the same size as ts, containing the result for each time.\n\nArguments\n\nSee arguments and keyword arguments that mcs_for_averaging.\nIf return_average = false (default), only produces the variance, else it  will produce a tuple, where the first element is the variance and the second the average.\n\n\n\n\n\n","category":"function"},{"location":"TWA/#DickeModel.TWA.variance","page":"TWA","title":"DickeModel.TWA.variance","text":"function variance(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_variance]]],\n    kargs...)\n\nCalls mcs_for_variance and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"function"},{"location":"TWA/#Survival-probability","page":"TWA","title":"Survival probability","text":"","category":"section"},{"location":"TWA/","page":"TWA","title":"TWA","text":"mcs_for_survival_probability\nsurvival_probability","category":"page"},{"location":"TWA/#DickeModel.TWA.mcs_for_survival_probability","page":"TWA","title":"DickeModel.TWA.mcs_for_survival_probability","text":"function mcs_for_survival_probability(\n    system::ClassicalSystems.ClassicalSystem;\n    N::Integer,\n    ts::AbstractArray{<:Real},\n    distribution::PhaseSpaceDistribution)\n\nGenerates a MonteCarloSystem that computes the survival probability through Eq. (C.7) of Ref. [19] (with M= N, w= distribution).\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem,\n\nKeyword arguments\n\nN is the number of points to sample. The bigger the more accurate.\nts should be a sorted array of times.\ndistribution should be an instance of PhaseSpaceDistribution\n\n\n\n\n\n","category":"function"},{"location":"TWA/#DickeModel.TWA.survival_probability","page":"TWA","title":"DickeModel.TWA.survival_probability","text":"function survival_probability(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_survival_probability]]],\n    kargs...)\n\nCalls mcs_for_survival_probability and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"function"},{"location":"TWA/#Matrix-distributions","page":"TWA","title":"Matrix distributions","text":"","category":"section"},{"location":"TWA/","page":"TWA","title":"TWA","text":"mcs_for_distributions\ncalculate_distribution","category":"page"},{"location":"TWA/#DickeModel.TWA.mcs_for_distributions","page":"TWA","title":"DickeModel.TWA.mcs_for_distributions","text":"function mcs_for_distributions(system::ClassicalSystems.ClassicalSystem;\n    x,\n    xs::Union{AbstractRange{<:Real},Nothing}=nothing,\n    y=nothing,\n    ts::Union{AbstractRange{<:Real},Nothing}=nothing,\n    animate::Bool=false,\n    ys::Union{AbstractRange{<:Real},Nothing}=nothing,\n    N::Integer,\n    distribution::PhaseSpaceDistribution)\n\nGenerates a MonteCarloSystem that produces a multidimensional histogram allowing to visualize the expected value of observables under PhaseSpaceDistribution distribution.\n\nSeveral behaviors can be produced.\n\nIf x is :t, a matrix of dimensions length(ts) times length(ys)  is produced. The coordinate (tᵢ,yⱼ) gives the probability of finding the observable y between ys[j] and ys[j+1] at the time ts[i].\nIf y is :t, the same as above, changing x by y.\nIf neither x nor y are :t, and animate = false, then a matrix of dimensions length(xs) times length(ys)  is produced.  The coordinate (xᵢ,yⱼ) gives the probability of finding the observable x between xs[i] and xs[i+1] and the observable y between ys[j] and ys[j+1], averaging over all the times in ts\nIf neither x nor y are t, and animate = true then an array of matrices of dimensions length(xs) times length(ys)  is produced, the same size as ts. For the nth matrix in this array, the coordinate (xᵢ,yⱼ) gives the probability of finding the observable x between xs[i] and xs[i+1] and the observable y between ys[j] and ys[j+1] at time ts[n].\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem,\n\nKeyword arguments\n\nx and y can be :t, or an observable as described in the arguments of mcs_for_averaging.\nxs and ys should be given if  x and  y are not  :t, in wich case they should be range objects (e.g. 0:0.1:1) containing the bins for the histogram.\nts should be a range object (e.g. 0:0.1:1) of times.\nanimate should be a Bool, which determines the behavior if neither x nor y are t. Defaults to true\nN is the number of points to sample. The bigger the more accurate.\ndistribution should be an instance of PhaseSpaceDistribution\n\nNote: If ts and y are both not passed, then y is set to :t and ts to 0:0.\n\n\n\n\n\n","category":"function"},{"location":"TWA/#DickeModel.TWA.calculate_distribution","page":"TWA","title":"DickeModel.TWA.calculate_distribution","text":"function calculate_distribution(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_distributions]]],\n    kargs...)\n\nCalls mcs_for_distributions and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"function"},{"location":"TWA/#DickeModel.TWA.Weyl","page":"TWA","title":"Weyl symbols","text":"","category":"section"},{"location":"TWA/","page":"TWA","title":"TWA","text":"The submodule TWA.Weyl generates classical phase-space observables that may be passed as the argument observable of average, calculate_distribution, etc. All the following functions return SymEngine objects, so they may be operated as if they were numbers. ","category":"page"},{"location":"TWA/","page":"TWA","title":"TWA","text":"Modules = [TWA.Weyl]\nOrder   = [:type,:function]","category":"page"},{"location":"TWA/#DickeModel.TWA.Weyl.Jx-Tuple{Real}","page":"TWA","title":"DickeModel.TWA.Weyl.Jx","text":"function Jx(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_x. (See p. 114 of Ref. [18])\n\n\n\n\n\n","category":"method"},{"location":"TWA/#DickeModel.TWA.Weyl.Jx²-Tuple{Real}","page":"TWA","title":"DickeModel.TWA.Weyl.Jx²","text":"function Jx²(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_x^2. (See bottom of p. 128 of Ref. [18])\n\n\n\n\n\n","category":"method"},{"location":"TWA/#DickeModel.TWA.Weyl.Jy-Tuple{Real}","page":"TWA","title":"DickeModel.TWA.Weyl.Jy","text":"function Jy(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_y. (See p. 114 of Ref. [18])\n\n\n\n\n\n","category":"method"},{"location":"TWA/#DickeModel.TWA.Weyl.Jy²-Tuple{Real}","page":"TWA","title":"DickeModel.TWA.Weyl.Jy²","text":"function Jy²(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_y^2. (See bottom of p. 128 of Ref. [18])\n\n\n\n\n\n","category":"method"},{"location":"TWA/#DickeModel.TWA.Weyl.Jz-Tuple{Real}","page":"TWA","title":"DickeModel.TWA.Weyl.Jz","text":"function Jz(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_z. (See p. 114 of Ref. [18])\n\n\n\n\n\n","category":"method"},{"location":"TWA/#DickeModel.TWA.Weyl.Jz²-Tuple{Real}","page":"TWA","title":"DickeModel.TWA.Weyl.Jz²","text":"function Jz²(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_z^2. (See bottom of p. 128 of Ref. [18])\n\n\n\n\n\n","category":"method"},{"location":"TWA/#DickeModel.TWA.Weyl.n-Tuple{Real}","page":"TWA","title":"DickeModel.TWA.Weyl.n","text":"function n(j::Real)\n\nReturns the Weyl symbol of the number operator W(n), (p²+  q² - ħ)/2, where ħ = 1/j.  \n\n\n\n\n\n","category":"method"},{"location":"TWA/#DickeModel.TWA.Weyl.n²-Tuple{Real}","page":"TWA","title":"DickeModel.TWA.Weyl.n²","text":"function n²(j::Real)\n\nReturns the Weyl symbol of the number operator squared W(n^2) = W(n)^2 - hbar^24, where hbar = 1j. (Note that the extra term hbar^24  appears due to the non-commutativity of q and p. See Ref. [16] for details on how to compute these expressions.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#DickeModel.DickeBCE","page":"DickeBCE","title":"DickeModel.DickeBCE","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"For examples of usage, go to  Examples for DickeBCE.","category":"page"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"CurrentModule = DickeModel.DickeBCE","category":"page"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"QuantumDickeSystem\nQuantumDickeSystem()\ndimension","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.QuantumDickeSystem","page":"DickeBCE","title":"DickeModel.DickeBCE.QuantumDickeSystem","text":"mutable struct QuantumDickeSystem <: ClassicalDicke.DickeSystem\n\nThis object represents the quantum Dicke model. It stores the parameters of the system, and it may be passed to multiple functions in this module. To generate it, use\n\nfunction QuantumDickeSystem(classical_system::ClassicalDicke.ClassicalDickeSystem;\n    j::Real,\n    Nmax::Union{Integer,Nothing}=nothing)\n\nor DickeBCE.QuantumDickeSystem(;ω₀,ω,γ,j,Nmax).\n\nBecause this object subtypes ClassicalDicke.DickeSystem, it may be passed to any function that requires a DickeSystem or a ClassicalSystem, and the underlying classical_system will be used.\n\nArguments\n\nclassical_system should be generated with ClassicalDicke.ClassicalDickeSystem.\nj is the value of j. It must be a positive half-integer.\nNmax - 1 is the maximum excitation of the modified bosonic sector in the efficient coherent basis (see [4], [5]). Nmax must be a positive integer.  It may be omitted. In this case, you may use functions that do not require Nmax. Moreover, if  you call diagonalization with a system that has Nmax = nothing,  and there is a  diagonalization saved in disk, diagonalization(system) will load  the eigenstates with the largest Nmax and will set the value of  Nmax in system.\n\n\n\n\n\n","category":"type"},{"location":"DickeBCE/#DickeModel.DickeBCE.QuantumDickeSystem-Tuple{}","page":"DickeBCE","title":"DickeModel.DickeBCE.QuantumDickeSystem","text":"function QuantumDickeSystem(;ω₀,ω,γ,j,Nmax=nothing)\n\nShorthand for  QuantumDickeSystem(ClassicalDicke.ClassicalDickeSystem(ω₀=ω₀, ω=ω, γ=γ), j=j, Nmax=Nmax).\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#DickeModel.DickeBCE.dimension","page":"DickeBCE","title":"DickeModel.DickeBCE.dimension","text":"function dimension(system::QuantumDickeSystem)\n\nReturns the integer (2j + 1)times N_textmax, which gives the dimension of the Hilbert space.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Diagonalization","page":"DickeBCE","title":"Diagonalization","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"diagonalization\neigenenergies\neigenstate_parities","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.diagonalization","page":"DickeBCE","title":"DickeModel.DickeBCE.diagonalization","text":"function diagonalization(system::QuantumDickeSystem;\n        load_cache::Bool = true,\n        save_cache::Bool = true,\n        cache_folder::AbstractString = joinpath(homedir(),\"dicke_diagonalizations\"),\n        maxϵ::Real = 5.0,\n        onlyload::Union{AbstractVector{<:Integer},Nothing} = nothing,\n        only_eigenenergies::Bool = false,\n        verbose::Bool = true,\n        converged_tolerance::Real = 1e-3)\n\nDiagonalizes the Dicke Hamiltonian up to a maximum energy maxϵ. The resulting eigenstates  are guaranteed to be converged, with a tolerance determined by converged_tolerance. Numerical degeneracies are also corrected, to ensure that the eigenstates have parity +1 or -1. If only_eigenenergies is false (default), a tuple (eigenenergies,eigenstates) is returned, where eigenenergies is real vector containing the eigenenergies and eigenstates is a real matrix that contains the eigenstates as columns. \n\nIf load_cache = true it will try to load saved diagonalizations from cache_folder. In the case that system has Nmax = nothing, the diagonalization with the largest Nmax will be loaded, and Nmax  will be set in system. \n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\n\nKeyword arguments\n\nload_cache is a boolean indicating whether to try to load from cache folder. Defaults to true.\nsave_cache determines if the results of a computed diagonalization are saved to the cache folder. Defaults to true.\ncache_folder is the cache folder where diagonalizations are saved. Default is %HOME%/dicke_diagonalizations\nmaxϵ is the maximum energy up to which we diagonalize. Keep this number  higher than the maximum converged regime you want.\nonlyload may be a vector of integers, indicating the indices of the eigenstates to load, or the default value, nothing, indicates that all eigenstates should be loaded.\nonly_eigenenergies should be true if you only to load the eigenenergies. Defaults to false (return eigenstates and eigenenergies).\nverbose is true (default) if you want to see info messages.\nconverged_tolerance determines how strict we are in saying that an eigenstate is converged (see [5]). The default value 1e-3 is usually the best.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.eigenenergies","page":"DickeBCE","title":"DickeModel.DickeBCE.eigenenergies","text":"function eigenenergies(system::QuantumDickeSystem;kargs...)\n\nReturns a vector containing the eigenenergies of the system. \n\nThis function is just shorthand for diagonalization(system;kargs..., only_eigenenergies = true). \n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.eigenstate_parities","page":"DickeBCE","title":"DickeModel.DickeBCE.eigenstate_parities","text":"function eigenstate_parities(system::QuantumDickeSystem,eigenstates::AbstractMatrix{<:Number})\n\nReturns a vector of -1s and 1s contaning the parities of all of the eigenstates.\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\neigenstates is the matrix of eigenstates. (See  diagonalization).\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Evolution","page":"DickeBCE","title":"Evolution","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"evolve\nsurvival_probability","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.evolve","page":"DickeBCE","title":"DickeModel.DickeBCE.evolve","text":"function evolve(t::Union{Real,AbstractArray{<:Real}}\n    state::AbstractVector{<:Number};\n    eigenstates::AbstractMatrix{<:Number},\n    eigenenergies::AbstractVector{<:Real},\n    normwarning::Real=0.99)\n\nComputes the evolution e^-i hatH t state rangle under the Dicke Hamiltonian hatH. The result is returned in the BCE.\n\nArguments\n\nt may be a single time, or a vector of times. In the first case, a vector will be  returned, and in the second, a matrix with each column corresponding to each time.\nstate is a vector representing the state in the BCE.\n\nKeyword arguments\n\neigenstates and eigenenergies are the ones returned by diagonalization.\nnormwarning is a tolerance (defaults to 0.99). If the norm of the state in the eigenbasis is below this number, a warning will be thrown. This usually happens if Nmax is too small for the energy regime you are working on.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.survival_probability","page":"DickeBCE","title":"DickeModel.DickeBCE.survival_probability","text":"function survival_probability(t::Union{Real,AbstractArray{<:Real}};\n    state::AbstractVector{<:Number},\n    eigenstates::AbstractMatrix{<:Number},\n    eigenenergies::AbstractVector{<:Real},\n    normwarning::Real=0.99)\n\nComputes the survival probability  langle state  e^-i hatH t  state rangle  ^2 at the times given.\n\nArguments\n\nt may be a single time, or a vector of times. In the first case, a number will be  returned, and in the second, a vector.\n\nKeyword arguments\n\nstate is a vector representing the state in the BCE.\neigenstates and eigenenergies are the ones returned by diagonalization.\nnormwarning is a tolerance (defaults to 0.99). If the norm of the state in the eigenbasis is below this number, a warning will be thrown. This usually happens if Nmax is too small for the energy regime you are working on.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Operators","page":"DickeBCE","title":"Operators","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"DickeBCE.Jx\nDickeBCE.Jz\nhamiltonian_operator\nparity_operator","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.Jx","page":"DickeBCE","title":"DickeModel.DickeBCE.Jx","text":"function Jx(system::QuantumDickeSystem)\n\nReturns a diagonal matrix representing the operator hatJ_x in the efficient coherent basis.\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.Jz","page":"DickeBCE","title":"DickeModel.DickeBCE.Jz","text":"function Jz(system::QuantumDickeSystem)\n\nReturns a sparse matrix representing the operator hatJ_z in the efficient coherent basis.\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.hamiltonian_operator","page":"DickeBCE","title":"DickeModel.DickeBCE.hamiltonian_operator","text":"function hamiltonian_operator(system::QuantumDickeSystem)\n\nReturns a sparse matrix corresponding to the Dicke Hamiltonian (See Eq. (1) of [14]) in the efficient coherent basis. (See Ref. [4], [5])\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.parity_operator","page":"DickeBCE","title":"DickeModel.DickeBCE.parity_operator","text":"function parity_operator(system::QuantumDickeSystem)\n\nReturns a sparse matrix corresponding to the parity operator hatPi=e^ipi(hata^daggerhata+ hatJ_z + j) in the efficient coherent basis.\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Participation-Ratio","page":"DickeBCE","title":"Participation Ratio","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"participation_ratio\nfactor_R_of_coherent_state","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.participation_ratio","page":"DickeBCE","title":"DickeModel.DickeBCE.participation_ratio","text":"function participation_ratio(state::AbstractVector{<:Number};\n    eigenstates::AbstractMatrix{<:Number},\n    eigenenergies::Union{AbstractVector{<:Real},Nothing}=nothing,\n    count_degeneracies::Bool=eigenenergies!=nothing,\n    degentol::Real=1e-5)\n\nReturns the Participation Ratio (PR) of state in the eigenbasis. If count_degeneracies is true, then Eq. (7) of [19] is used. If count_degeneracies is false, then the inverse of Eq. (19) of [19] is used.\n\nArguments\n\nstate should be a complex vector representing the state in the efficient coherent basis.\n\nKeyword arguments\n\neigenstates should be a matrix containing the eigenstates.\neigenenergies should be passed if count_degeneracies is  true. It is a list containing the eigenenergies.\ncount_degeneracies – whether to modify the PR definition to account for degeneracies (see above).  Default is false if eigenenergies is not passed, else it is true.\ndegentol minimum energy separation below which two eigenstates are considered degenerate. Default is 1e-5.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.factor_R_of_coherent_state","page":"DickeBCE","title":"DickeModel.DickeBCE.factor_R_of_coherent_state","text":"function factor_R_of_coherent_state(system::QuantumDickeSystem,\n        x::AbstractVector{<:Real};\n        eigenstates::AbstractMatrix{<:Number},\n        eigenenergies::AbstractVector{<:Real},\n        state::AbstractVector{<:Number} = coherent_state(system,x))\n\nComputes R for a coherent state, as defined in Eq. (30) of [19].\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nx is an array [Q,q,P,p] representing the center of the coherent state.\n\nKeyword arguments\n\neigenstates should be a matrix containing the eigenstates as columns.\neigenenergies  is a list containing the eigenenergies.\nstate is a complex vector representing the coherent state left  mathbfx right rangle. If it is not passed, it is computed using DickeBCE.coherent_state\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Coherent-states","page":"DickeBCE","title":"Coherent states","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"coherent_state!\ncoherent_state","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.coherent_state!","page":"DickeBCE","title":"DickeModel.DickeBCE.coherent_state!","text":"function coherent_state!(system::QuantumDickeSystem,\n            x::AbstractArray{<:Real,1},\n            data::AbstractVector{<:Number};\n            normwarning=0.99,\n            add_state_to_data::Bool=false,\n            extra_phase::Complex=1.0+0im,\n            chop::Real=1e-6)\n\nThis function computes the coefficients of a coherent state centered at  x in the BCE, and stores the result in data. (See Ref. [19])\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nx is a vector with the coordinates [Q, q, P, p].\ndata should be a complex vector of length dimension(system).\n\nKeyword arguments\n\nnormwarning is a tolerance (defaults to 0.99). If the norm of the resulting coherent state is below this number, a warning will be thrown. This usually happens if Nmax is too small for the energy regime you are working on.\nadd_state_to_data is a boolean. If it is true, the coefficients will be added to data. If it is false (default), this function will override any preexisting values in data. This is useful if you want to add many coherent states together without having to allocate that much memory.   \nextra_phase is a complex number that multiplies the resulting state overall.  Defaults to 1.\nchop is a numerical tolerance between 0 and 1. If chop=0, then all the coefficients all computed. However, if ε = 1 -  chop > 0.0, then some coefficients at the tail of the distribution (whose total squared norm does not exceed ε) will be treated as 0.0. This allows to  significantly reduce computation time, but introduces a numerical error of order ε. The default is 1e-6. See this example and Ref. [11].\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.coherent_state","page":"DickeBCE","title":"DickeModel.DickeBCE.coherent_state","text":"function coherent_state(system::QuantumDickeSystem,\n    x::AbstractVector{<:Real};\n    normwarning::Real=0.99,\n    extra_phase::Complex=1.0+0im,\n    chop::Real=0.0)\n\nCalls coherent_state! passing data as a new vector and returns the result.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Overlaps","page":"DickeBCE","title":"Overlaps","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"coherent_overlap\nhusimi\nhusimi_of_coherent","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.coherent_overlap","page":"DickeBCE","title":"DickeModel.DickeBCE.coherent_overlap","text":"function coherent_overlap(system::QuantumDickeSystem,\n    x::AbstractVector{<:Real},\n    state::AbstractVector{<:Number};\n    chop::Real=1e-6,\n    normwarning::Real=0.99,\n    datacache::Union{AbstractArray{Complex{Float64},1},Nothing}=nothing)\n\nReturns  the overlap langle mathbfx  state rangle, where left  mathbfx right rangle is a coherent state centered at x.\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nx is a vector in the form [Q, q, P, p].\nstate is a vector in the BCE.\n\nKeyword arguments\n\nchop is a numerical tolerance between 0 and 1. If chop = 0, then all the products of coefficients are computed. However, if ε = 1 -  chop > 0.0, then some coefficients of the coherent state at the tail of the distribution  (whose total squared norm does not exceed ε) will be treated as 0.0. This allows to  significantly reduce computation time, but introduces a numerical error of order ε. The default is 1e-6. See this example  and Ref. [11].\nnormwarning is a tolerance (defaults to 0.99). If the norm of the coherent  state is below this number, a warning will be thrown.  This usually happens if Nmax is too small for the energy regime you are working on.\ndatacache in an array where to store the result, or nothing for the result to be returned. \n\n\n\n\n\nfunction coherent_overlap(system::QuantumDickeSystem,\n    x::AbstractVector{<:Real},\n    states::AbstractMatrix{<:Number};\n    chop::Real=1e-6,\n    normwarning::Real=0.99,\n    datacache::Union{AbstractVector{<:Complex},Nothing}=nothing)\n\nSame as coherent_overlap(..., state,...), but instead of one state, it allows states to be a matrix with multiple states as columns. It is functionally equivalent to\n\n[coherent_overlap(..., states[:,k], ...) for k in 1:size(states)[2]]\n\nbut it is (much) faster. The result is stored in datacache if provided.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.husimi","page":"DickeBCE","title":"DickeModel.DickeBCE.husimi","text":"function husimi(args...;kargs...)\n\nComputes abs2.(coherent_overlap(args...;kargs...)). The arguments and behavior are the same as coherent_overlap.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.husimi_of_coherent","page":"DickeBCE","title":"DickeModel.DickeBCE.husimi_of_coherent","text":"function husimi_of_coherent(system::QuantumDickeSystem,\n    x::AbstractArray{<:Real,1},\n    y::AbstractArray{<:Real,1})\n\nReturns  left  left langle mathbfxmiddle  mathbfyright rangle right  ^2.  Equation (3.14b) of Ref. [2] is used for the overlap of the Bloch coherent states.\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nx and y are vectors in the form [Q, q, P, p].\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Semiclassical-approximations","page":"DickeBCE","title":"Semiclassical approximations","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"density_of_states\nenergy_width_of_coherent_state","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.density_of_states","page":"DickeBCE","title":"DickeModel.DickeBCE.density_of_states","text":"function density_of_states(system::QuantumDickeSystem, ϵ::Real)\n\nReturns the semiclassical density of states (DoS) ν(ϵ), in units of 1ϵ, as given by Eq. (A1) of Ref. [15]. \n\nThis is computed by multiplying  the volume of the classical energy shell at ϵ  by (2pi hbar_texteff)^2=(2 pi  j)^2 (see  ClassicalDicke.energy_shell_volume).\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nϵ is the scaled energy ϵ=Ej\n\nSee Plotting the semiclassical density of states for an example.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.energy_width_of_coherent_state","page":"DickeBCE","title":"DickeModel.DickeBCE.energy_width_of_coherent_state","text":"function energy_width_of_coherent_state(system::QuantumDickeSystem,\n                                        x::AbstractVector{<:Real})\n\nReturns the energy width sigma of the coherent state left  mathbfxright rangle, in units of epsilon. This quantity is given by sigma_Dj with sigma_D as in App. A of Ref. [7].\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nx is the coordinate mathbfx of the coherent state in the format [Q,q,P,p].\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Random-states","page":"DickeBCE","title":"Random states","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"random_cₖ_generator\nrandom_state!\nrandom_state\nrandom_coherent_states_in_energy_shell","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.random_cₖ_generator","page":"DickeBCE","title":"DickeModel.DickeBCE.random_cₖ_generator","text":"function random_cₖ_generator(system::QuantumDickeSystem;\n                            kargs...)\n\nGenerates coefficients to build random states, which are given by\n\n    c_k(epsilon_k) sim e^i theta_k sqrtfracr_krho(epsilon_k)nu(epsilon_k)\n\n(See Refs. [8], [19], and [14]). It returns a function cₖ(ϵ;number=1,cache=nothing), which produces n=number coefficients, storing them in cache (an n-vector), if given.\n\nThe parameters of the equation above are determined as follows:\n\nRequired keyword arguments\n\nTo determine  rho(epsilon) above, pass either: \nσ and ϵ, both real, in which case rho will be taken as a normal distribution centered at ϵ with standard deviation σ,\nOR envelope as any of Distributions.UnivariateDistribution.\nTo determine r_k, pass either:\nensemble = :GUE, which takes r_k from an exponential distribution Exponential(0.91) or ensemble = :GOE, which takes r_k from a chi^2 distribution with one degree of freedom,\nOR rₖ_distribution as any of Distributions.UnivariateDistribution.\nTo determine theta_k, pass either:\nphases = :real, which takes theta_k to be random from  -pi pi  or phases = :complex, which takes theta_k to be uniform in 0 2pi),\nOR ensemble = :GOE, which automatically sets phases = :real, or ensemble = :GUE, which automatically sets phases = :complex.\n\nOptional keyword arguments\n\ndivide_by_DoS is a boolean. If true (default), leaves the density of states, nu(epsilon_k) in the equation above. A value of false removes it.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.random_state!","page":"DickeBCE","title":"DickeModel.DickeBCE.random_state!","text":"function random_state!(system::QuantumDickeSystem,\n    data::AbstractVecOrMat{<:Number};\n    kargs...)\n\nGenerates as many random states as columns in data saving the result to data. The general form of the random states in the eigenbasis is left  R right rangle = sum_k c_k left  E_k right rangle, where the c_k are computed using random_cₖ_generator. You may choose to select only positive or negative parity eigenstates (see below).\n\nArguments\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\ndata should be a vector or matrix of numbers, where the result is stored. It must have as many columns as random numbers you want and dimension(system) rows.\n\nRequired keyword arguments\n\nPlease pass all the required keyword arguments of random_cₖ_generator.\neigenstates and eigenenergies shoud be passed, being the ones returned by diagonalization.\n\nOptional keyword arguments\n\nAll the optional keyword arguments of random_cₖ_generator may be passed.\ntol may be a real number which determines the tolerance for the state convergence. A value tol=0 builds the state with all of the eigenstates, and a positive number cuts the tails of the energy envelope up to that number. Higher values are faster,  but decrease precision (Defaults to 1e-6)\nparity may be +, -, or nothing (default). If it is not nothing, the random will be composed of only the eigenstates with this parity.\nparities should be passed if parity is not nothing. It should be a vector of -1s  and 1s containing the parities of all of the eigenstates. If it is not passed, it will be  computed with eigenstate_parities, but this is slow. If you plan to use this function repeatedly, you should precompute parities by calling eigenstate_parities  yourself and then pass it to parities to avoid repeated calls to eigenstate_parities.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.random_state","page":"DickeBCE","title":"DickeModel.DickeBCE.random_state","text":"function random_state(system::QuantumDickeSystem,\n                    n::Int=1;\n                    kargs...)\n\nGenerates n random states, returning them as columns in a matrix (or a vector if n = 1, which is the default). kargs are redirected to random_state!: some additional keyword arguments are required: see random_state!.\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.random_coherent_states_in_energy_shell","page":"DickeBCE","title":"DickeModel.DickeBCE.random_coherent_states_in_energy_shell","text":"function random_coherent_states_in_energy_shell(\n    system::QuantumDickeSystem;\n    ϵ::Real,\n    N::Integer,\n    dt::Real=3,\n    chop::Real=1e-6,\n    cachedata::Union{AbstractVector{<:Complex},Nothing}=nothing)\n\nSamples N points from the energy shell at ϵ using ClassicalDicke.classical_path_random_sampler, and then constructs the N-cat state of all the coherent states centered at those points. \n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Wigner-functions","page":"DickeBCE","title":"Wigner functions","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"Wigner \nWignerProjQP\nWignerProjqp","category":"page"},{"location":"DickeBCE/#DickeModel.DickeBCE.Wigner","page":"DickeBCE","title":"DickeModel.DickeBCE.Wigner","text":"function Wigner(system::QuantumDickeSystem,\n    state::AbstractArray{<:Number},\n    points::Vector{<:AbstractVector{<:Real}})\n\nEvaluates the Wigner function of state (which is a vector in the BCE) in all points = [[Q1,q1,P1,p1], [Q2,q2,P2,p2], ...], returning an array with the results.\n\nNote: This function has not been thoroughly tested. It is based on Ref. [10].\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.WignerProjQP","page":"DickeBCE","title":"DickeModel.DickeBCE.WignerProjQP","text":"function WignerProjQP(system::QuantumDickeSystem,\n    state::AbstractArray{<:Number},\n    ptsqp::Vector{<:AbstractVector{<:Real}})\n\nEvaluates Wigner function, integrated over the atomic variables QP, of state  in all ptsqp = [[q1,p1], [q2,p2], ...], returning an array with the results.\n\nNote: This function has not been thoroughly tested. It is based on Ref. [10].\n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#DickeModel.DickeBCE.WignerProjqp","page":"DickeBCE","title":"DickeModel.DickeBCE.WignerProjqp","text":"function WignerProjqp(system::QuantumDickeSystem,\n    states::AbstractArray{<:AbstractArray{<:Number}},\n    ptsQP::Vector{<:AbstractVector{<:Real}};\n    show_progress::Bool=true)\n\nEvaluates Wigner function, integrated over the bosonic variables qp, of each of the states in states  (which is a vector of complex vectors)  in all ptsQP = [[Q1,P1], [Q2,P2], ...], returning an array with the results. See this example. If show_progress = true it shows a progress bar.\n\nNote: This function has not been thoroughly tested. It is based on Ref. [10].\n\n\n\n\n\n","category":"function"},{"location":"ClassicalSystems/#DickeModel.ClassicalSystems","page":"ClassicalSystems","title":"DickeModel.ClassicalSystems","text":"","category":"section"},{"location":"ClassicalSystems/","page":"ClassicalSystems","title":"ClassicalSystems","text":"CurrentModule = DickeModel.ClassicalSystems","category":"page"},{"location":"ClassicalSystems/","page":"ClassicalSystems","title":"ClassicalSystems","text":"ClassicalSystem","category":"page"},{"location":"ClassicalSystems/#DickeModel.ClassicalSystems.ClassicalSystem","page":"ClassicalSystems","title":"DickeModel.ClassicalSystems.ClassicalSystem","text":"abstract struct ClassicalSystem\n\nThis abstract object represents a classical system that may be passed to multiple functions in this module. To generate a system, use ClassicalDicke.ClassicalDickeSystem or use ClassicalLMG.ClassicalLMGSystem.\n\n\n\n\n\n","category":"type"},{"location":"ClassicalSystems/#Classical-evolution","page":"ClassicalSystems","title":"Classical evolution","text":"","category":"section"},{"location":"ClassicalSystems/","page":"ClassicalSystems","title":"ClassicalSystems","text":"integrate(::ClassicalSystem,::AbstractVector{<:Real},::Real)","category":"page"},{"location":"ClassicalSystems/#DickeModel.ClassicalSystems.integrate-Tuple{DickeModel.ClassicalSystems.ClassicalSystem, AbstractVector{var\"#s25\"} where var\"#s25\"<:Real, Real}","page":"ClassicalSystems","title":"DickeModel.ClassicalSystems.integrate","text":"function integrate(system::ClassicalSystem,\n                   u₀::AbstractVector{<:Real},\n                   t::Real;\n                   t₀=0.0::Real,\n                   tol=1e-12::Real,\n                   get_fundamental_matrix::Bool=false,\n                   integrator_alg=TsitPap8(),\n                   use_big_numbers::Bool=false,\n                   integate_backwards::Bool=false,\n                   fundamental_matrix_initial=nothing,\n                   kargs...)\n\nThis function integrates initial condition u₀ from t₀ to t under the Hamiltonian system determined by system, returning an instance of OrdinaryDiffEq.ODESolution.\n\nArguments\n\nsystem is an instance of ClassicalSystems.ClassicalSystem.\nu₀ is an array which codifies the initial condition [Q,q,P,p] for ClassicalDicke and [Q,P] for ClassicalLMG.\nt is the start time of the integration.\n\nKeyword arguments\n\nt₀ is the start of the integration (defaults to t₀ = 0.0) ClassicalSystems.ClassicalSystem.\ntol is the tolerance for the integration, which determines both abstol and reltol in OrdinaryDiffEq.solve\nget_fundamental_matrix determines whether to also compute the fundametal matrix of the system. If true, the result at each time is an ArrayPartition(x,Φ), so that x=result.x[2] retrieves the coordinate and Ψ=result.x[2] retrieves the fundamental matrix. Default is false. Note that the integration is consideribly slowed down if this parameter is set to true.\nintegrator_alg is the integration algorithm to use. Defaults to TsitPap8 (Tsitouras-Papakostas 8/7 Runge-Kutta method). See the DifferentialEquations documentation for other options.\nuse_big_numbers forces the integration to be performed with BigFloat instead of Float, allowing for infinite numerical precision, but hindering speed substantially. Defaults to false.\nintegate_backwards tells the integrator to integrate back in time, from -t₀ to -t. Defaults to  false.\nfundamental_matrix_initial is the initial value if get_fundamental_matrix is true. The default value is the identity matrix.\nAdditional kargs are passed to OrdinaryDiffEq.solve.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Lyapunov-exponents","page":"ClassicalSystems","title":"Lyapunov exponents","text":"","category":"section"},{"location":"ClassicalSystems/","page":"ClassicalSystems","title":"ClassicalSystems","text":"lyapunov_spectrum\nlyapunov_exponent","category":"page"},{"location":"ClassicalSystems/#DickeModel.ClassicalSystems.lyapunov_spectrum","page":"ClassicalSystems","title":"DickeModel.ClassicalSystems.lyapunov_spectrum","text":"function lyapunov_spectrum(system::ClassicalSystem,\n    x::AbstractVector{<:Real},\n    t::Real = 100;\n    λtol::Real = 1e-5, \n    λreltol::Real = 1e-3,\n    maxiters::Integer = 100,\n    verbose::Bool = true,\n    kargs...)\n\nCalculates the Lyapunov spectrum at point x. The algorithm used is given in Fig. 3.7 of Ref. [9], which basically integrates the fundamental matrix and renormalizes in intervals of length t, until the oscillations of the Lyapunov exponets go bellow λtol + λ*λreltol.\n\nArguments\n\nsystem is an instance of ClassicalSystems.ClassicalSystem.\nx is an array which codifies the initial condition [Q,q,P,p] for ClassicalDicke and [Q,P] for ClassicalLMG.\nt is the time intervals for which to integrate. This value must not be too big, or the fundamental matrix may get too large and errors will occur.  Default value is 100, which is fine most of the time.\n\nKeyword arguments\n\nλtol is the absolute tolerance (E_a in Fig. 3.7 of Ref. [9]). Default is 1e-5.\nλreltol is the relative tolerance (E_r in Fig. 3.7 of Ref. [9]). Default is 1e-3.\nmaxiters is the maximum number of iterations. Default is 100.\nverbose is a boolean toggling the progress bar (default is true, which enables the progress bar).\nkargs are redirected to integrate. \n\n\n\n\n\n","category":"function"},{"location":"ClassicalSystems/#DickeModel.ClassicalSystems.lyapunov_exponent","page":"ClassicalSystems","title":"DickeModel.ClassicalSystems.lyapunov_exponent","text":"function lyapunov_exponent(system::ClassicalSystem,\n    x::AbstractVector{<:Real},\n    t::Real = 100; kargs...)\n\nReturns the maximal Lyapunov exponent for x by calling maximum(lyapunov_spectrum(system, x, t; kargs...)). Same arguments as lyapunov_spectrum apply.\n\n\n\n\n\n","category":"function"},{"location":"#[DickeModel.jl](https://github.com/saulpila/DickeModel.jl)","page":"DickeModel.jl","title":"DickeModel.jl","text":"","category":"section"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"A toolkit for the quantum and classical Dicke model in Julia.","category":"page"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"<img src=\"banner.png\" id=\"bannerimage\" width=\"100%\" style=\"margin-bottom: 1em;\"/>\n<script> \n    document.getElementById(\"bannerimage\").style.filter = \"hue-rotate(\"+Math.random()+\"turn)\"\n</script> ","category":"page"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"This package contains numerical methods that allow to efficiently compute properties of the quantum and classical Dicke model, a fundamental model in quantum optics describing atoms interacting with light.","category":"page"},{"location":"#Installation","page":"DickeModel.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"To install the package, use the following command inside the Julia REPL:","category":"page"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"using Pkg\nPkg.add(\"DickeModel\")","category":"page"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"note: Note\nThe package is currently under registration in the Julia official registry. While that  goes through, instead use:using Pkg\nPkg.add(PackageSpec(url = \"https://github.com/saulpila/DickeModel.jl\"))","category":"page"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"To load the package, use the command:","category":"page"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"using DickeModel","category":"page"},{"location":"#Getting-started","page":"DickeModel.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"There are many things you can do using the different submodules:","category":"page"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"ClassicalDicke allows to compute classical dynamics of the Dicke model, including a wide range of properites of its phase space (used in [12], [13], [14], [15], [19],  [20]).\nSee Examples for ClassicalDicke.\nDickeBCE provides multiple functions for analyzing the quantum Dicke model. It uses an efficient basis known as the Efficient Coherent Basis (BCE) [4], [5] for exact computations, and it also contains several semilcassical methods (used in [12], [13], [14], [15], [19],  [20]).\nSee Examples for DickeBCE.\nUPOs contains a set of functions to find unstable periodic orbits (UPOs) in the classical Dicke model and to study quantum scars (used in  [13], [14], [15]).\nSee Examples for UPOs.\nTWA allows to perform semiclassical calculations using the truncated Wigner approximation (TWA) (used in [12], [19]).\nSee Examples for TWA.\nEnergyShellProjections contains a set of functions to integrate functions over the classical energy shells of the Dicke Model. It also contains specialized functions to compute these integrals for the Husimi functions of quantum states, which define phase-space localization measures known as Rényi occupations [20] (used in [14], [15], [20]).\nSee Examples for EnergyShellProjections.\nClassicalLMG provides very basic functions for the classical Lipkin-Meshkov-Glick model.\nSee Examples for ClassicalLMG.","category":"page"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"The following modules provide basic functionallity for the rest of the modules:","category":"page"},{"location":"","page":"DickeModel.jl","title":"DickeModel.jl","text":"ClassicalSystems provides a general framework for computing classical Hamiltonian dynamics, inlcuding Lyapunov exponents. It is mostly used for the Dicke model, but in principle it can be expanded to other Hamiltonians.\nPhaseSpaces provides some canonical transformations of the Bloch-Sphere.","category":"page"}]
}
