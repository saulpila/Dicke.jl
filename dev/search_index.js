var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"DickeHusimiProjections/#Dicke.DickeHusimiProjections","page":"DickeHusimiProjections","title":"Dicke.DickeHusimiProjections","text":"","category":"section"},{"location":"DickeHusimiProjections/","page":"DickeHusimiProjections","title":"DickeHusimiProjections","text":"Modules = [Dicke.DickeHusimiProjections]\nOrder   = [:function, :type]","category":"page"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation","text":"","category":"section"},{"location":"TruncatedWignerApproximation/","page":"TruncatedWignerApproximation","title":"TruncatedWignerApproximation","text":"Modules = [Dicke.TruncatedWignerApproximation]\nOrder   = [:function, :type]","category":"page"},{"location":"ClassicalLMG/#Dicke.ClassicalLMG","page":"ClassicalLMG","title":"Dicke.ClassicalLMG","text":"","category":"section"},{"location":"ClassicalLMG/","page":"ClassicalLMG","title":"ClassicalLMG","text":"Modules = [Dicke.ClassicalLMG]\nOrder   = [:function, :type]","category":"page"},{"location":"UPOS/#Dicke.UPOS","page":"UPOS","title":"Dicke.UPOS","text":"","category":"section"},{"location":"UPOS/","page":"UPOS","title":"UPOS","text":"Modules = [Dicke.UPOS]\nOrder   = [:function, :type]","category":"page"},{"location":"FOTOCTWA/#Dicke.FOTOCTWA","page":"FOTOCTWA","title":"Dicke.FOTOCTWA","text":"","category":"section"},{"location":"FOTOCTWA/","page":"FOTOCTWA","title":"FOTOCTWA","text":"Modules = [Dicke.FOTOCTWA]\nOrder   = [:function, :type]","category":"page"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces","page":"PhaseSpaces","title":"Dicke.PhaseSpaces","text":"","category":"section"},{"location":"PhaseSpaces/","page":"PhaseSpaces","title":"PhaseSpaces","text":"Modules = [Dicke.PhaseSpaces]\nOrder   = [:function, :type]","category":"page"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke","page":"ClassicalDicke","title":"Dicke.ClassicalDicke","text":"","category":"section"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"Modules = [Dicke.ClassicalDicke]\nOrder   = [:function, :type]","category":"page"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.ClassicalSystem-Tuple{}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.ClassicalSystem","text":"function ClassicalSystem(;ω₀,ω,γ)\n\nGenerates an instance of ClassicalSystems.ClassicalSystem which represents the classical Dicke model with the given parameters ω_0, ω, and γ. See Eq. (5) of Ref. Saúl Pilatowsky-Cameo, David Villaseñor, Miguel A. Bastarrachea-Magnani, Sergio Lerma-Hernández, Lea F. Santos, Jorge G. Hirsch (2021).\n\nThe returned value may be passed to all functions in this module that require an instance of ClassicalSystems.ClassicalSystem, as well as functions in other modules, such as  ClassicalSystems.integrate.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.Point-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.Point","text":"function Point(system::ClassicalSystems.ClassicalSystem;Q,P,p,ε,signo::Union{typeof(-),typeof(+)}=+)\n\nReturns a list [Q,q,P,p], where q is calculated with ClassicalDicke.q_of_ε. See that function for details on the arguments. If there are no solutions for q, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.Pointθϕ-Tuple{}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.Pointθϕ","text":"function Pointθϕ(;θ,ϕ,q,p)\n\nReturns a list [Q,q,P,p], where Q and P are calculated from θ and ϕ using PhaseSpaces.Q_of_θϕ and  PhaseSpaces.P_of_θϕ.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.density_of_states-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.density_of_states","text":"function density_of_states(system::ClassicalSystems.ClassicalSystem;j,ε)\n\nReturns the semiclassical density of states (DoS) ν(ϵ), in units of 1ϵ. This is computed with an expression similar to Eq. (19) of Ref. M. A. Bastarrachea-Magnani, S. Lerma-Hernández, J. G. Hirsch (2014), where we add an additional factor of j to have units of 1ϵ instead of 1E, and the integral is performed with a change of variable.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nj is the value of j\nε is the scaled energy ϵ=Ej\n\nSee Plotting the density of states for an example.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.discriminant_of_q_solution-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.discriminant_of_q_solution","text":"function discriminant_of_q_solution(system::ClassicalSystems.ClassicalSystem; Q,P,p,ε)\n\nReturns the discriminant of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nwhere h_textcl is given by Eq. (5) of Ref. Saúl Pilatowsky-Cameo, David Villaseñor, Miguel A. Bastarrachea-Magnani, Sergio Lerma-Hernández, Lea F. Santos, Jorge G. Hirsch (2021).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nQ, P, p, and ε are the values of Q, P, p, and epsilon, respectively.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.energy_shell_volume-Tuple{Dicke.ClassicalSystems.ClassicalSystem, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.energy_shell_volume","text":"function energy_shell_volume(system::ClassicalSystems.ClassicalSystem;ε)\n\nReturns the volume of the classical energy shell in the phase space, that is, mathcalV(mathcalM_ϵ) in Eq. (27) of Ref. Saúl Pilatowsky-Cameo, Jorge Chávez-Carlos, Miguel A. Bastarrachea-Magnani, Pavel Stránský, Sergio Lerma-Hernández, Lea F. Santos, Jorge G. Hirsch (2020).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nε is the scaled energy ϵ=Ej\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.energy_width_of_coherent_state-Tuple{Dicke.ClassicalSystems.ClassicalSystem, Any, Real}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.energy_width_of_coherent_state","text":"function energy_width_of_coherent_state(system::ClassicalSystems.ClassicalSystem,x,j::Real)\n\nReturns the energy width sigma of the coherent state left  mathbfxright rangle, in units of epsilon. This quantity is given by sigma_Dj with sigma_D as in App. A of Ref. Sergio Lerma-Hernández, Jorge Chávez-Carlos, Miguel A. Bastarrachea-Magnani, Lea F. Santos, Jorge G. Hirsch (2018).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nx is the coordinate mathbfx of the coherent state in the format [Q,q,P,p].\nj is the value of j.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.hamiltonian-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.hamiltonian","text":"function hamiltonian(system::ClassicalSystems.ClassicalSystem)\n\nReturns a classical Hamiltonian function h(x) where x=[Q,q,P,p], which is given by Eq. (5) of Ref. Saúl Pilatowsky-Cameo, David Villaseñor, Miguel A. Bastarrachea-Magnani, Sergio Lerma-Hernández, Lea F. Santos, Jorge G. Hirsch (2021).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.maximum_P_for_ε-Tuple{Dicke.ClassicalSystems.ClassicalSystem, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.maximum_P_for_ε","text":"function maximum_P_for_ε(system::ClassicalSystems.ClassicalSystem,ε)\n\nComputes the maximum value of the parameter P accessible to the system at energy epsilon.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nε is the scaled energy ϵ=Ej.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.maximum_Q_for_ε-Tuple{Dicke.ClassicalSystems.ClassicalSystem, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.maximum_Q_for_ε","text":"function maximum_Q_for_ε(system::ClassicalSystems.ClassicalSystem,ε)\n\nSee ClassicalDicke.maximum_P_for_ε.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.minimum_energy-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.minimum_energy","text":"function minimum_energy(system::ClassicalSystems.ClassicalSystem)\n\nReturns the energy of the ground-state coordinate given by ClassicalDicke.minimum_energy_point.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\n\nNote: This function currently only works for the supperadiant phase.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.minimum_energy_point","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.minimum_energy_point","text":"function minimum_energy_point(system::ClassicalSystems.ClassicalSystem,Qsign::Union{typeof(-),typeof(+)}=+)\n\nReturns the ground-state coordinate, that is, mathbfx_textGS below Eq. (7) of Ref. Saúl Pilatowsky-Cameo, David Villaseñor, Miguel A. Bastarrachea-Magnani, Sergio Lerma-Hernández, Lea F. Santos, Jorge G. Hirsch (2021).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nQsign toggles the sign of the Q coordinate, that is, + for mathbfx_textGS and  - for widetildemathbfx_textGS.\n\nNote: This function currently only works for the superradiant phase.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.minimum_ε_for-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.minimum_ε_for","text":"function minimum_ε_for(system::ClassicalSystems.ClassicalSystem;Q=:nothing,q=:nothing,P=:nothing,p=:nothing)\n\nReturns the minimum energy epsilon when constraining the system to three fixed values of the coordinates Q, q, P, p.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nYou may pass either (QqP) or (qPp). The other combinanations are not implemented.\n\nThis function can be especially useful to draw contours of the available phase space (see Drawing contours of the available phase space)\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.normal_frequency","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.normal_frequency","text":"function normal_frequency(system::ClassicalSystems.ClassicalSystem,signo::Union{typeof(-),typeof(+)}=+)\n\nReturns the ground-state normal frequency, that is, Omega_epsilon_textGS^AB at the bottom of page 3 of Ref. Saúl Pilatowsky-Cameo, David Villaseñor, Miguel A. Bastarrachea-Magnani, Sergio Lerma-Hernández, Lea F. Santos, Jorge G. Hirsch (2021).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nsigno is - for Omega^A and + for Omega^B.\n\nNote: This function currently only works for the supperadiant phase.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.phase_space_dist_squared-Tuple{Any, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.phase_space_dist_squared","text":"function phase_space_dist_squared(x,y)\n\nReturns the phase-space distance d_mathcalM(mathbfxmathbfy) (See App. C of Ref Saúl Pilatowsky-Cameo, David Villaseñor, Miguel A. Bastarrachea-Magnani, Sergio Lerma-Hernández, Lea F. Santos, Jorge G. Hirsch (2021)), where x and y are in the form [Q,q,P,p].\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.q_of_ε-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.q_of_ε","text":"function q_of_ε(system::ClassicalSystems.ClassicalSystem;Q,P,p,ε,signo::Union{typeof(-),typeof(+)}=+,returnNaNonError=true)\n\nReturns the solutions q_pm of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nwhere h_textcl is given by Eq. (5) of Ref. Saúl Pilatowsky-Cameo, David Villaseñor, Miguel A. Bastarrachea-Magnani, Sergio Lerma-Hernández, Lea F. Santos, Jorge G. Hirsch (2021).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nQ, P, p, and ε are values of Q, P, p, and epsilon, respectively.\nsigno is + for q_+ and - for q_-\nIf returnNaNonError is true, then NaN is returned if there are no solutions. If it is false, and error is raised.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.q_sign","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.q_sign","text":"function q_sign(system::ClassicalSystems.ClassicalSystem,x,ε=hamiltonian(system)(x))\n\nReturns the sign of the root of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nThat is, this function returns + if q=x[2] ≈ q_of_ε(system;Q=x[1],P=x[3],p=x[4],ε=ε,signo=+) and returns - if q=x[2] ≈ q_of_ε(system;Q=x[1],P=x[3],p=x[4],ε=ε,signo=-).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nx is a vector in the form [Q,q,P,p].\nε should be the energy of x. If this is not passed, it is computed using hamiltonian(system). \n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\nusing Dicke","category":"page"},{"location":"examples/#(Semi)classical-Dicke-model","page":"Examples","title":"(Semi)classical Dicke model","text":"","category":"section"},{"location":"examples/#Drawing-contours-of-the-available-phase-space","page":"Examples","title":"Drawing contours of the available phase space","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We may use the function ClassicalDicke.minimum_ε_for to draw the contour of the available phase space on the variables (QP).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Dicke.ClassicalDicke\nusing Plots\nsystem =  ClassicalDicke.ClassicalSystem(ω=1, γ=1, ω₀=1)\nQs = Ps = -2:0.01:2\nεgs = minimum_energy(system)\ncontour(Qs, Ps,\n        (Q,P) -> minimum_ε_for(system, p=0, P=P, Q=Q),\n        levels=10, clim=(εgs,1), xlabel=\"Q\", ylabel=\"P\")\nsavefig(\"contourQP.svg\"); nothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Plotting-the-density-of-states","page":"Examples","title":"Plotting the density of states","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is a plot of the semiclassical density of states","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Dicke.ClassicalDicke\nusing Plots\nsystem = ClassicalDicke.ClassicalSystem(ω=1, γ=1, ω₀=1)\nν(ε) = density_of_states(system, j=100, ε=ε)\nεgs = minimum_energy(system)\nplot(ν, εgs, 2, xlabel=\"ε\", ylabel=\"Density of States\")\nplot!(key=false) #hide\nsavefig(\"density_of_states.svg\"); nothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is precisely the red line in Fig. A1. of Ref. David Villaseñor, Saúl Pilatowsky-Cameo, Miguel A Bastarrachea-Magnani, Sergio Lerma, Lea F Santos, Jorge G Hirsch (2020).","category":"page"},{"location":"examples/#Drawing-a-Poincaré-surface","page":"Examples","title":"Drawing a Poincaré surface","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here is a way to draw a Poincaré surface for the Dicke model. We use ClassicalSystems.integrate to integrate a bunch of initial conditions. Using the callback system of DifferentialEquations, we save the points where p=0.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Dicke, Dicke.ClassicalDicke, Dicke.ClassicalSystems\nusing Plots\nusing DiffEqBase\n\nsystem=ClassicalDicke.ClassicalSystem(ω=0.8,γ=0.8,ω₀=1)\nmplot=scatter(fmt=:png, key=false, markersize=1, legend=false,\n    size=(500,500), color_palette=:darkrainbow, xlabel=\"Q\", ylabel=\"P\") \n\npts = Tuple{Float64, Float64}[] #a list of points (Q,P)\nfunction save(state) #this function saves (Q,P) to pts if q = q₊ (and not q₋).\n    if q_sign(system,state.u,ε) == + \n        Q,q,P,p = state.u \n        push!(pts, (Q,P))  \n    end                     \nend\ncallback=ContinuousCallback((x, t, _) -> x[4], #when p=x[4] is 0,\n    save; #execute the function save\n    save_positions=(false,false), abstol=1e-3)\nε = -1.35\nfor Q in 0:0.02:maximum_Q_for_ε(system, ε) #for a bunch of initial Qs,\n        if minimum_ε_for(system, P=0, p=0, Q=Q) > ε\n            continue\n        end\n        initial_condition = Point(system, ε=ε, P=0, p=0, Q=Q)\n        integrate(system, u₀=initial_condition,\n            t=10000, callback=callback, save_everystep=false)\n        scatter!(pts)\n        empty!(pts)\n        if !on_github break end #hide\n\n\nend\nmplot\nsavefig(\"poincare_surface.png\");nothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Drawing-a-Lyapunov-exponent-map","page":"Examples","title":"Drawing a Lyapunov exponent map","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let us plot the Lyapunov exponents for the Poincaré map of the previous example.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Dicke, Dicke.ClassicalDicke, Dicke.ClassicalSystems\nusing Plots\nusing DiffEqBase\n\nsystem = ClassicalDicke.ClassicalSystem(ω=0.8, γ=0.8, ω₀=1)\nε = -1.35\n\nresolution = 0.01 #making this smaller will make a smoother plot,\n                  #but it may take time!\nmaxQ = maximum_Q_for_ε(system,ε) \nmaxP = maximum_P_for_ε(system,ε) \n\nQs = 0.6:resolution:maxQ\nPs = 0.0:resolution:maxP  #we only compute the top half of \n                          #the plane, and later mirror it\n\n#this matrix contains NaNs (outside of bounds) and tuples [λ,n] \n#(inside of bounds), where λ is an average of all the Lyapunov \n#exponents of the n trajectories that have passed through that square\nmatrix = [if minimum_ε_for(system, P=P, p=0, Q=Q) > ε \n            NaN else [0.0,0] end \n                for Q in Qs, P in Ps] \n\npts = Tuple{Float64, Float64}[] #a list of points (Q,P) for temporary storage\n\nfunction save(state) #this function saves (Q,P) to pts if q = q₊ (and not q₋).\n    if q_sign(system,state.u,ε) == + \n        Q,q,P,p = state.u \n        push!(pts, (Q,P))  \n    end                     \nend\ncallback=ContinuousCallback((x, t, _) -> x[4], #when p=x[4] is 0,\n    save; #execute the function save\n    save_positions=(false,false), abstol=1e-3)\n#an auxiliary function, which gives the index k so that r[k] ≥ v >r[k]\nfunction index_of_subinterval(v,r) \n    if r[end] <v\n        return length(r)\n    end\n    if v < r[1] \n        return 1\n    end\n    return Int(round(((v-r[1])/(r[end]-r[1]))*(length(r)-1) +1))\nend\n#we iterate over the matrix and the values of Q,P\nfor ((Q,P),element) in zip(Iterators.product(Qs,Ps),matrix)\n    #if we are out of bounds or we have information on this Lyapunov exponent,\n    if element===NaN || element[2] > 0 \n        continue #we skip\n    end\n    \n    #the following 4 lines will populate pts with all the points (mQ,mP) in the \n    #Poincaré map that the trajectory starting at (Q,P) passes through.\n    empty!(pts)\n    push!(pts,(Q,P))\n    point  = Point(system, Q=Q, P=P, p=0, ε=ε)\n    λ = lyapunov_exponent(system, t=5000, u₀ = point,callback = callback,tol=1e-9)\n    \n    \n    for (mQ,mP) in pts\n        #we save the Lyapunov into all of the squares that the trajectory visited.\n        el = matrix[index_of_subinterval(mQ,Qs),index_of_subinterval(abs(mP),Ps)]\n        #if we are inside bounds\n        if el !== NaN\n           \n            el[1] = (el[1]*el[2] + λ)/(el[2] + 1)  #we update the average\n            el[2] += 1 #we update the count\n        end\n    end\n    if !on_github break end #hide\nend\n\nmat=transpose([v[1] for v in matrix]) #we take the average Lyapunovs, and tranpose\n#because heatmap takes transposed matrices.\n\nmat=vcat(mat[end:-1:2,1:end], mat) #mirror in P\nPs=vcat(-Ps[end:-1:2], Ps) #update Ps with negative values\n\nheatmap(Qs, Ps, mat, xlabel=\"Q\", ylabel=\"P\",size=(550,500))\nsavefig(\"lyapunov_map.svg\");nothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"It looks very similar to the Poincaré map of the previous example! Notice how there are regular (black) and chaotic (colored) regions.","category":"page"},{"location":"DickeBCE/#Dicke.DickeBCE","page":"DickeBCE","title":"Dicke.DickeBCE","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"Modules = [Dicke.DickeBCE]\nOrder   = [:function, :type]","category":"page"},{"location":"DickeBCE/#Dicke.DickeBCE.H_BCE-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.H_BCE","text":"function H_BCE(system::QuantumSystem)\n\nReturns a sparse matrix corresponding to the Dicke Hamiltonian (see any of the references. For example, Eq. (1) of Saúl Pilatowsky-Cameo, David Villasañor, Miguel A. Bastarrachea-Magnani, Sergio Lerma-Hernández, Lea F. Santos, Jorge G. Hirsch (2021)) in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Jx-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.Jx","text":"function Jx(system::QuantumSystem)\n\nReturns a sparse matrix representing the operator hatJ_x in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Jz-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.Jz","text":"function Jz(system::QuantumSystem)\n\nReturns a sparse matrix representing the operator hatJ_z in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.diagonalization-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.diagonalization","text":"function diagonalization(systemQ::QuantumSystem;\n        load_cache = true,\n        save_cache = true,\n        cache_folder = joinpath(homedir(),\"dicke_diagonalizations\"),\n        maxε::Real = 5.0,\n        onlyload::Union{AbstractVector{<:Integer},Nothing} = nothing,\n        only_eigenenergies = false,\n        converged_tolerance=1e-3)\n\nIf load_cache = false or there are no saved diagonalizations in cache_folder, diagonalizes the Dicke Hamiltonian up to a maximum energy maxε. These eigenstates  are guaranteed to be converged, with a tolerance determined by converged_tolerance. Numerical degeneracies are also corrected, to ensure that the eigenstates have parity +1 or -1. If only_eigenenergies is false (default), a tuple (eigenenergies,eigenstates) is returned, where eigenenergies is real vector containing the eigenenergies and eigenstates is a real matrix that contains the eigenstates as columns. \n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\nload_cache is a boolean indicating whether to try to load from cache folder. Defaults to true.\nsave_cache determines if the results of a computed diagonalization are saved to the cache folder. Defaults to true.\ncache_folder is the cache folder where diagonalizations are saved. Default is %HOME%/dicke_diagonalizations\nmaxε is the maximum energy up to which we diagonalize. Keep this number  higher than the maximum converged regime you want.\nonlyload may be a vector of integers, indicating the indices of the eigenstates to load, or the default value, nothing, indicates that all eigenstates should be loaded.\nonly_eigenenergies should be true if you only to load the eigenenergies. Defaults to false (return eigenstates and eigenenergies).\nconverged_tolerance determines how strict we are in saying that an eigenstate is converged. The default value 1e-3 is usually the best.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.eigenenergies-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.eigenenergies","text":"function eigenenergies(systemQ::QuantumSystem;args...)\n\nReturns a vector containing the eigenenergies of the system. These are loaded or computed as in diagonalization. \n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\nargs... same as in diagonalization).\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.eigenstate_parities-Tuple{Dicke.DickeBCE.QuantumSystem, Any}","page":"DickeBCE","title":"Dicke.DickeBCE.eigenstate_parities","text":"function eigenstate_parities(system::QuantumSystem,eigenstates)\n\nReturns a vector of -1s and 1s contaning the parities of all of the eigenstates.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\neigenstates is the matrix of eigenstates. (See  diagonalization).\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.factor_R_of_coherent_state-Tuple{Dicke.DickeBCE.QuantumSystem, Any}","page":"DickeBCE","title":"Dicke.DickeBCE.factor_R_of_coherent_state","text":"function factor_R_of_coherent_state(system::QuantumSystem,\n    x;\n    eigenstates,\n    eigenenergies,\n    state = coherentBCE(system,x))\n\nComputes R for a coherent state, as defined in Eq. (30) of David Villaseñor, Saúl Pilatowsky-Cameo, Miguel A Bastarrachea-Magnani, Sergio Lerma, Lea F Santos, Jorge G Hirsch (2020).\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\nx is an array [Q,q,P,p] representing the center of the coherent state.\neigenstates should be a matrix containing the eigenstates as columns.\neigenenergies  is a list containing the eigenenergies.\nstate is a complex vector representing the coherent state left  mathbfx right rangle. If it is not passed, it is computed using DickeBCE.coherentBCE\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.participation_ratio-Tuple{Any}","page":"DickeBCE","title":"Dicke.DickeBCE.participation_ratio","text":"function participation_ratio(state;eigenstates,eigenenergies=nothing,count_degeneracies=eigenenergies!=nothing,degentol=1e-5)\n\nReturns the Participation Ratio (PR) of state in the eigenbasis. If count_degeneracies is true, then Eq. (7) of David Villaseñor, Saúl Pilatowsky-Cameo, Miguel A Bastarrachea-Magnani, Sergio Lerma, Lea F Santos, Jorge G Hirsch (2020) is used. If count_degeneracies is false, then the inverse of Eq. (19) of David Villaseñor, Saúl Pilatowsky-Cameo, Miguel A Bastarrachea-Magnani, Sergio Lerma, Lea F Santos, Jorge G Hirsch (2020) is used.\n\nArguments:\n\nstate should be a complex vector representing the state in the efficient coherent basis.\neigenstates should be a matrix containing the eigenstates.\neigenenergies should be passed if count_degeneracies is  true. It is a list containing the eigenenergies.\ncount_degeneracies – whether to modify the PR definition to account for degeneracies (see above).  Default is false if eigenenergies is not passed, else it is true.\ndegentol minimum energy separation below which two eigenstates are considered degenerate. Default is 1e-5.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.survival_probability-Tuple{Union{Real, AbstractArray{var\"#s16\", N} where {var\"#s16\"<:Real, N}}}","page":"DickeBCE","title":"Dicke.DickeBCE.survival_probability","text":"function survival_probability(t::Union{Real,AbstractArray{<:Real}};\n    state,\n    eigenstates,\n    eigenenergies,\n    normwarning=0.99)\n\nPENDING\n\nArguments:\n\nPENDING\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Π_BCE-Tuple{Dicke.DickeBCE.QuantumSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.Π_BCE","text":"function Π_BCE(system::QuantumSystem)\n\nReturns a sparse matrix corresponding to the parity operator hatPi=e^ipi(hata^daggerhata+ hatJ_z + j) in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.QuantumSystem","page":"DickeBCE","title":"Dicke.DickeBCE.QuantumSystem","text":"mutable struct QuantumSystem\n\nThis object represents the quantum Dicke model. It stores the parameters of the system, and it may be passed to multiple functions in this module. To generate a QuantumSystem, use QuantumSystem or use ClassicalDicke.ClassicalSystem.\n\n\n\n\n\n","category":"type"},{"location":"DickeBCE/#Dicke.DickeBCE.QuantumSystem-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.QuantumSystem","text":"function QuantumSystem(system::ClassicalSystems.ClassicalSystem;j,Nmax=nothing)\n\nReturns a  QuantumSystem given j, N_textmax, ω_0, ω, and γ. \n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalSystem.\nj is the value of j.\nNmax is the maximum excitation of the modified bosonic sector in the efficient coherent basis (see Miguel A Bastarrachea-Magnani, Jorge G Hirsch (2014)). It may be omitted if there is a saved diagonalization.  In that case, a call to diagonalization will populate this value with the  greatest available in the saved cache.    \n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems","page":"ClassicalSystems","title":"Dicke.ClassicalSystems","text":"","category":"section"},{"location":"ClassicalSystems/","page":"ClassicalSystems","title":"ClassicalSystems","text":"Modules = [Dicke.ClassicalSystems]\nOrder   = [:function, :type]","category":"page"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.integrate-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.integrate","text":"function integrate(system::ClassicalSystem;t::Real,\n                   u₀::AbstractArray{<:Real, 1},\n                   t₀=0.0::Real,\n                   tol=1e-12::Real,\n                   get_fundamental_matrix::Bool=false,\n                   integrator_alg=TsitPap8(),\n                   use_big_numbers::Bool=false,\n                   integate_backwards::Bool=false,\n                   kargs...)\n\nThis function integrates initial condition u₀ from t₀ to t under the Hamiltonian system determined by system, returning an instance of ODESolution from the     package DifferentialEquations (See https://diffeq.sciml.ai/dev/basics/solution/).\n\nArguments:\n\nsystem is an instance of ClassicalSystems.ClassicalSystem.\nu₀ is an array which codifies the initial condition [Q,q,P,p] for ClassicalDicke and [Q,P] for ClassicalLMG.\nt is the start time of the integration.\nt₀ is the start of the integration (defaults to t₀ = 0.0) ClassicalSystems.ClassicalSystem.\ntol is the tolerance for the integration, which determines both abstol and reltol in https://diffeq.sciml.ai/stable/basics/commonsolveropts/\nget_fundamental_matrix determines whether to also compute the fundametal matrix of the system. If true, the result at each time is an ArrayPartition(x,Φ), so that x=result.x[2] retrieves the coordinate and Ψ=result.x[2] retrieves the fundamental matrix. Default is false. Note that the integration is consideribly slowed down if this parameter is set to true.\nintegrator_alg is the integration algorithm to use. Defaults to TsitPap8 (Tsitouras-Papakostas 8/7 Runge-Kutta method). See https://diffeq.sciml.ai/stable/solvers/ode_solve/#Full-List-of-Methods for other options.\nuse_big_numbers forces the integration to be performed with BigFloat instead of Float, allowing for infinite numerical precision, but hindering speed substantially. Defaults to false.\nintegate_backwards tells the integrator to integrate back in time, from -t₀ to -t. Defaults to  false.\nAdditional kargs are passed to OrdinaryDiffEq.solve (see https://diffeq.sciml.ai/stable/basics/commonsolveropts/).\n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.lyapunov_exponent-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.lyapunov_exponent","text":"function lyapunov_exponent(system::ClassicalSystem;kargs...)\n\nReturns the maximal Lyapunov exponent for system.\n\nArguments\n\nsystem is an instance of ClassicalSystems.ClassicalSystem.\nkargs... are redirected to ClassicalSystems.integrate. In particular, you should pass u₀ and t.\n\nPENDING EXAMPLE\n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.lyapunov_spectrum-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.lyapunov_spectrum","text":"function lyapunov_spectrum(system::ClassicalSystem;kargs...)\n\nSame as ClassicalSystems.lyapunov_exponent, but returns the whole Lyapunov spectrum.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.ClassicalSystem","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.ClassicalSystem","text":"struct ClassicalSystem\n\nThis object represents a classical system that may be passed to multiple functions in this module. To generate a system, use ClassicalDicke.ClassicalSystem or use ClassicalDicke.ClassicalSystem.\n\n\n\n\n\n","category":"type"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"This package is a result of more than two years of investigation of the Dicke Model. It contains numerical methods that were used in the following publications:","category":"page"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"Quantum localization measures in phase space.  Physical Review E 103 052214 (2021) DOI: 10.1103/physreve.103.052214\nUbiquitous quantum scarring does not prevent ergodicity.  Nature Communications 12 852 (2021) DOI: 10.1038/s41467-021-21123-5\nQuantum scarring in a spin-boson system: fundamental families of periodic orbits.  New Journal of Physics 23 033045 (2021) DOI: 10.1088/1367-2630/abd2e6\nQuantum vs classical dynamics in a spin-boson system: manifestations of spectral correlations and scarring.  New Journal of Physics 22 063036 (2020) DOI: 10.1088/1367-2630/ab8ef8\nPositive quantum Lyapunov exponents in experimental systems with a regular classical limit.  Physical Review E 101 010202(R) (2020) DOI: 10.1103/PhysRevE.101.010202","category":"page"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"It is split into several submodules:","category":"page"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"ClassicalDicke allows to compute classical dynamics of the Dicke model, including a wide range of semiclassical aproximations to quantum properties.\nClassicalSystems provides a general framework for computing classical Hamiltonian dynamics, inlcuding Lyapunov exponents. It is mostly used for the Dicke model, but in principle it can be expanded to other Hamiltonians.\nDickeBCE provides multiple functions for analyzing the quantum Dicke model. It uses an efficient basis known as the Efficient Coherent Basis (BCE). See Refs. above.\nUPOS contains a set of functions to find unstable periodic orbits (UPOs) in the classical Dicke model. (See Ref. 3)\nTruncatedWignerApproximation allows to perform semiclassical calculations using the truncated Wigner approximation (TWA). (See Ref 2)\nFOTOCTWA is a small module providing functions to compute the fidelity out-of-order-time correlator using the TWA.  (See Ref 5)\nDickeHusimiProjections contains a set of functions to integrate functions over the classical energy shells of the Dicke Model. It also contains specialized functions to compute these integrals for the Husimi functions of quantum states, which define phase-space localization measures known as Rényi occupations (See Refs. 1 and 2)\nClassicalLMG provides very basic functions for the classical Lipkin-Meshkov-Glick model. (See Ref. 5)\nPhaseSpaces provides some canonical transformations of the Bloch-Sphere.","category":"page"}]
}
